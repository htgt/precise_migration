.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PM_WHICH 1"
.TH PM_WHICH 1 "2013-07-25" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
pm_which \- find installed modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    pm_which [ options ] module(s)
\&
\&    Returns the path to the given module(s)
.Ve
.SS "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
.Vb 11
\&    \-q, \-\-quiet     Just print paths
\&    \-p, \-\-paths     Just convert the module name into a relative path
\&    \-a, \-\-all       Print all paths, not just the first one found
\&    \-n, \-\-namespace Print all modules in the given namespace
\&    \-m              Only print module names, not paths
\&    \-V              Show module version
\&    \-I libpath      Add a path to search (like perl \-I)
\&    \-d, \-\-dump      Dump paths that would be searched (@INC by default)
\&    \-h, \-\-help      Print this message
\&    \-v, \-\-version   Print version information
\&    \-               Read modules from stdin, one per line
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This tool reports the locations of installed perl modules.
.PP
By default it lists the location of each specified module that would be loaded
by require.
.SH "OPTION DETAILS"
.IX Header "OPTION DETAILS"
.SS "quiet"
.IX Subsection "quiet"
Under quiet mode, module names are suppressed and missing modules are not
reported.
.PP
Normal output:
.PP
.Vb 4
\&    $ pm_which Module::One Module::Two Missing::Module
\&    Module::One     \- /path/to/Module/One.pm
\&    Module::Two     \- /path/to/Module/Two.pm
\&    Missing::Module \- not found
.Ve
.PP
Under \-\-quiet:
.PP
.Vb 3
\&    $ pm_which \-q Module::One Module::Two Missing::Module
\&    /path/to/Module/One.pm
\&    /path/to/Module/Two.pm
.Ve
.SS "paths"
.IX Subsection "paths"
In \*(L"paths\*(R" mode, each module is simply converted into a relative file path. This
is possible even when the module is not installed.
.PP
.Vb 2
\&    $ pm_which \-p Missing::Module
\&    Missing/Module.pm
.Ve
.SS "all"
.IX Subsection "all"
When the \*(L"all\*(R" switch is specified, all installed modules will be reported, not
just the first one. This is useful for determining when there is a module
installed in multiple locations.
.PP
.Vb 3
\&    $ pm_which \-a MyModule
\&    /path/to/MyModule.pm
\&    /home/me/perl/MyModule.pm
.Ve
.SS "namespace"
.IX Subsection "namespace"
Arguments are taken as namespaces to search under.
.PP
.Vb 4
\&    $ pm_which \-n MyModule
\&    MyModule            \- /path/to/MyModule.pm
\&    MyModule::Foo       \- /path/to/MyModule/Foo.pm
\&    MyModule::Foo::Bar  \- /path/to/MyModule/Foo/Bar.pm
.Ve
.SS "\-m"
.IX Subsection "-m"
Disables printing of module paths. This is only really useful in conjunction with \-\-namespace.
.PP
.Vb 4
\&    $ pm_which \-nm MyModule
\&    MyModule
\&    MyModule::Foo
\&    MyModule::Foo::Bar
.Ve
.SS "\-V"
.IX Subsection "-V"
Prints the version of each module, according to ExtUtils::MakeMaker.
.PP
.Vb 2
\&    $ pm_which \-V MyModule
\&    MyModule \- /path/to/MyModule.pm [ 1.00 ]
\&
\&    $ pm_which \-Vnm MyModule
\&    MyModule [ 1.00 ]
\&    MyModule::Foo [ 0.01 ]
\&    MyModule::Foo::Bar [ undef ]
.Ve
.SS "dump"
.IX Subsection "dump"
Dumps the paths that would be searched and exits. This is \f(CW@INC\fR modified by any
\&\-I switches.
.PP
.Vb 4
\&    $ pm_which \-\-dump
\&    /usr/lib/perl5/site_perl/5.8.6
\&    /usr/lib/perl5/vendor_perl/5.8.6
\&    ...
\&
\&    $ pm_which \-I lib \-\-dump \-I blib/lib
\&    lib
\&    blib/lib
\&    /usr/lib/perl5/site_perl/5.8.6
\&    ...
.Ve
.SS "version"
.IX Subsection "version"
Prints the version number of the script, plus the version and path of
Module::Util that was loaded.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
.IP "\(bu" 4
0 \- Everything was \s-1OK\s0
.IP "\(bu" 4
1 \- Initialisation failed (bad switches?)
.IP "\(bu" 4
2 \- Some modules were not installed
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This utility comes with Module::Util.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Lawrence <mattlaw@cpan.org>
