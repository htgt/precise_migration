.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cache::Entry 3"
.TH Cache::Entry 3 "2006-01-31" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cache::Entry \- interface for a cache entry
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  my Cache::Entry $entry = $cache\->entry( $key )
\&  my $data;
\&  if ($entry\->exists()) {
\&      $data = $entry\->get();
\&  }
\&  else {
\&      $data = get_some_data($key);
\&      $entry\->set($data, \*(Aq10 minutes\*(Aq);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objects derived from Cache::Entry represent an entry in a Cache.  Methods are
provided that act upon the data in the entry, and allow you to set things like
the expiry time.
.PP
Users should not create instances of Cache::Entry directly, but instead use
the entry($key) method of a Cache instance.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $cache = $e\->\fIcache()\fR" 4
.el .IP "my \f(CW$cache\fR = \f(CW$e\fR\->\fIcache()\fR" 4
.IX Item "my $cache = $e->cache()"
Returns a reference to the cache object this entry is from.
.ie n .IP "my $key = $e\->\fIkey()\fR" 4
.el .IP "my \f(CW$key\fR = \f(CW$e\fR\->\fIkey()\fR" 4
.IX Item "my $key = $e->key()"
Returns the cache key this entry is associated with.
.ie n .IP "my $bool = $e\->\fIexists()\fR" 4
.el .IP "my \f(CW$bool\fR = \f(CW$e\fR\->\fIexists()\fR" 4
.IX Item "my $bool = $e->exists()"
Returns a boolean value (1 or 0) to indicate whether there is any data
present in the cache for this entry.
.ie n .IP "$e\->set( $data, [ $expiry ] )" 4
.el .IP "\f(CW$e\fR\->set( \f(CW$data\fR, [ \f(CW$expiry\fR ] )" 4
.IX Item "$e->set( $data, [ $expiry ] )"
Stores the data into the cache.  The data must be a scalar (if you want to
store more complex data types, see freeze and thaw below).
.Sp
The expiry time may be provided as an optional 2nd argument and is in the same
form as for 'set_expiry($time)'.
.ie n .IP "my $data = $e\->\fIget()\fR" 4
.el .IP "my \f(CW$data\fR = \f(CW$e\fR\->\fIget()\fR" 4
.IX Item "my $data = $e->get()"
Returns the data from the cache, or undef if the entry doesn't exist.
.ie n .IP "my $size = $e\->\fIsize()\fR" 4
.el .IP "my \f(CW$size\fR = \f(CW$e\fR\->\fIsize()\fR" 4
.IX Item "my $size = $e->size()"
Returns the size of the entry data, or undef if the entry doesn't exist.
.ie n .IP "$e\->\fIremove()\fR" 4
.el .IP "\f(CW$e\fR\->\fIremove()\fR" 4
.IX Item "$e->remove()"
Clear the data for this entry from the cache.
.ie n .IP "my $expiry = $e\->\fIexpiry()\fR" 4
.el .IP "my \f(CW$expiry\fR = \f(CW$e\fR\->\fIexpiry()\fR" 4
.IX Item "my $expiry = $e->expiry()"
Returns the expiry time of the entry, in seconds since the epoch.
.ie n .IP "$e\->set_expiry( $time )" 4
.el .IP "\f(CW$e\fR\->set_expiry( \f(CW$time\fR )" 4
.IX Item "$e->set_expiry( $time )"
Set the expiry time in seconds since the epoch, or alternatively using a
string like '10 minutes'.  Valid units are s, second, seconds, sec, m, minute,
minutes, min, h, hour, hours, w, week, weeks, M, month, months, y, year and
years.  You can also specify an absolute time, such as '16 Nov 94 22:28:20' or
any other time that Date::Parse can understand.  Finally, the strings 'now'
and 'never' may also be used.
.ie n .IP "my $fh = $e\->handle( [$mode, [$expiry] ] )" 4
.el .IP "my \f(CW$fh\fR = \f(CW$e\fR\->handle( [$mode, [$expiry] ] )" 4
.IX Item "my $fh = $e->handle( [$mode, [$expiry] ] )"
Returns an IO::Handle by which data can be read, or written, to the cache.
This is useful if you are caching a large amount of data \- although it should
be noted that only some cache implementations (such as Cache::File) provide an
efficient mechanism for implementing this.
.Sp
The optional mode argument can be any of the perl mode strings as used for the
open function '<', '+<', '>', '+>', '>>' and '+>>'.  Alternatively it can be
the corresponding \fIfopen\fR\|(3) modes of 'r', 'r+', 'w', 'w+', 'a' and 'a+'.  The
default mode is '+<' (or 'r+') indicating reading and writing.
.Sp
The second argument is used to set the expiry time for the entry if it doesn't
exist already and the handle is opened for writing.  It is also used to reset
the expiry time if the entry is truncated by opening in the '>' or '+>' modes.
If the expiry is not provided in these situations then the default expiry time
for the cache is applied.
.Sp
Cache implementations will typically provide locking around cache entries, so
that writers will have have an exclusive lock and readers a shared one.  Thus
the method \fIget()\fR (or obtaining another handle) should be avoided whilst a
write handle is held.  Using \fIset()\fR or \fIremove()\fR, however, should be supported.
These clear the current entry and whilst they do not invalidate open handles,
those handle will from then on refer to old data and any changes to the data 
will be discarded.
.SH "STORING VALIDITY OBJECTS"
.IX Header "STORING VALIDITY OBJECTS"
There are two additional set & get methods that can be used to store a
validity object that is associated with the data in question.  Typically this
is useful in conjunction with a validate_callback, and may be used to store a
timestamp or similar to validate against.  The validity data stored may be any
complex data that can be serialized via Storable.
.ie n .IP "$e\->\fIvalidity()\fR" 4
.el .IP "\f(CW$e\fR\->\fIvalidity()\fR" 4
.IX Item "$e->validity()"
.PD 0
.ie n .IP "$e\->set_validity( $data )" 4
.el .IP "\f(CW$e\fR\->set_validity( \f(CW$data\fR )" 4
.IX Item "$e->set_validity( $data )"
.PD
.SH "STORING COMPLEX OBJECTS"
.IX Header "STORING COMPLEX OBJECTS"
The set and get methods only allow for working with simple scalar types, but
if you want to store more complex types they need to be serialized first.  To
assist with this, the freeze and thaw methods are provided.  They are simple
wrappers to get & set that use Storable to do the serialization and
de-serialization of the data.
.PP
Note, however, that you must be careful to \s-1ONLY\s0 use 'thaw' on data that was
stored via 'freeze'.  Otherwise the stored data wont actually be in Storable
format and it will complain loudly.
.ie n .IP "$e\->freeze( $data, [ $expiry ] )" 4
.el .IP "\f(CW$e\fR\->freeze( \f(CW$data\fR, [ \f(CW$expiry\fR ] )" 4
.IX Item "$e->freeze( $data, [ $expiry ] )"
Identical to 'set', except that data may be any complex data type that can be
serialized via Storable.
.ie n .IP "$e\->\fIthaw()\fR" 4
.el .IP "\f(CW$e\fR\->\fIthaw()\fR" 4
.IX Item "$e->thaw()"
Identical to 'get', except that it will return a complex data type that was
set via 'freeze'.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Cache, Cache::File
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Chris Leishman <chris@leishman.org>
\& Based on work by DeWitt Clinton <dewitt@unto.net>
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\& Copyright (C) 2003\-2006 Chris Leishman.  All Rights Reserved.
.Ve
.PP
This module is distributed on an \*(L"\s-1AS IS\*(R"\s0 basis, \s-1WITHOUT WARRANTY OF ANY KIND,\s0
either expressed or implied. This program is free software; you can
redistribute or modify it under the same terms as Perl itself.
.PP
\&\f(CW$Id:\fR Entry.pm,v 1.8 2006/01/31 15:23:58 caleishm Exp $
