.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Std 3"
.TH Config::Std 3 "2013-07-25" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Std \- Load and save configuration files in a standard format
.SH "VERSION"
.IX Header "VERSION"
This document describes Config::Std version 0.900
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Config::Std;
\&
\&    # Load named config file into specified hash...
\&    read_config \*(Aqdemo2.cfg\*(Aq => my %config;
\&
\&    # Extract the value of a key/value pair from a specified section...
\&    $config_value = $config{Section_label}{key};
\&
\&    # Change (or create) the value of a key/value pair...
\&    $config{Other_section_label}{other_key} = $new_val;
\&
\&    # Update the config file from which this hash was loaded...
\&    write_config %config;
\&
\&    # Write the config information to another file as well...
\&    write_config %config, $other_file_name;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements yet another damn configuration-file system.
.PP
The configuration language is deliberately simple and limited, and the
module works hard to preserve as much information (section order,
comments, etc.) as possible when a configuration file is updated.
.PP
The whole point of Config::Std is to encourage use of one standard layout
and syntax in config files. Damian says "I could have gotten away with it, I would have
only allowed one separator. But it proved impossible to choose between \f(CW\*(C`:\*(C'\fR and \f(CW\*(C`=\*(C'\fR
(half the people I asked wanted one, half wanted the other)." 
Providing round-trip file re-write is the spoonful of sugar to help the medicine go down.
The supported syntax is within the general \s-1INI\s0 file family
.PP
See Chapter 19 of \*(L"Perl Best Practices\*(R" (O'Reilly, 2005) 
for more detail on the
rationale for this approach.
.SS "Configuration language"
.IX Subsection "Configuration language"
The configuration language is a slight extension of the Windows \s-1INI\s0 format.
.PP
\fIComments\fR
.IX Subsection "Comments"
.PP
A comment starts with a \f(CW\*(C`#\*(C'\fR character (Perl-style) or a \f(CW\*(C`;\*(C'\fR character
(INI-style), and runs to the end of the same line:
.PP
.Vb 1
\&    # This is a comment
\&
\&    ; Ywis, eke hight thilke
.Ve
.PP
Comments can be placed almost anywhere in a configuration file, except inside
a section label, or in the key or value of a configuration variable:
.PP
.Vb 2
\&    # Valid comment
\&    [ # Not a comment, just a weird section label ]
\&
\&    ; Valid comment
\&    key: value  ; Not a comment, just part of the value
.Ve
.PP
\&\s-1NOTE BENE\s0 \*(-- that last is a \s-1BAD EXAMPLE\s0 of what is \s-1NOT\s0 supported. 
This module supports full-line comments only, not on same line with semantic content.
.PP
\fISections\fR
.IX Subsection "Sections"
.PP
A configuration file consists of one or more \fIsections\fR, each of which is
introduced by a label in square brackets:
.PP
.Vb 1
\&    [SECTION1]        # Almost anything is a valid section label
\&
\&    [SECTION 2]       # Internal whitespace is allowed (except newlines)
\&
\&    [%^$%^&!!!]       # The label doesn\*(Aqt have to be alphanumeric
\&
\&    [ETC. ETC. AS MANY AS YOU WANT]
.Ve
.PP
The only restriction on section labels is that they must be by
themselves on a single line (except for any surrounding whitespace or
trailing comments), and they cannot contain the character \f(CW\*(C`]\*(C'\fR.
.PP
Every line after a given section label until the next section label (or
the end of the config file) belongs to the given section label. If no
section label is currently in effect, the current section has an empty
label. In other words, there is an implicit:
.PP
.Vb 1
\&    []                # Label is the empty string
.Ve
.PP
at the start of each config file.
.PP
\fIConfiguration variables\fR
.IX Subsection "Configuration variables"
.PP
Each non-empty line within a section must consist of the specification of a
\&\fIconfiguration variable\fR. Each such variable consists of a key and a string
value. For example:
.PP
.Vb 2
\&    name: George
\&     age: 47
\&
\&    his weight! : 185
.Ve
.PP
The key consists of every character (including internal whitespace) from
the start of the line until the key/value separator. So, the previous
example declares three keys: \f(CW\*(Aqname\*(Aq\fR, \f(CW\*(Aqage\*(Aq\fR, and \f(CW\*(Aqhis weight!\*(Aq\fR.
.PP
Note that whitespace before and after the key is removed. This makes it easier
to format keys cleanly:
.PP
.Vb 3
\&           name : George
\&            age : 47
\&    his weight! : 185
.Ve
.PP
The key/value separator can be either a colon (as above) or an equals sign,
like so:
.PP
.Vb 3
\&           name= George
\&            age=  47
\&    his weight! = 185
.Ve
.PP
Both types of separators can be used in the same file, but neither can
be used as part of a key. Newlines are not allowed in keys either.
.PP
When writing out a config file, Config::Std tries to preserve whichever
separator was used in the original data (if that data was read
in). New data 
(created by code not parsed by \f(CW\*(C`read_config\*(C'\fR)
is written back with a colon as its default separator,
unless you specify the only other separator value \f(CW\*(Aq=\*(Aq\fR when the module is loaded:
.PP
.Vb 1
\&    use Config::Std { def_sep => \*(Aq=\*(Aq };
.Ve
.PP
Note that this does not change read-in parsing, 
does not change punctuation for values that were parsed, 
and will not allow values other than \f(CW\*(Aq=\*(Aq\fR or \f(CW\*(Aq:\*(Aq\fR.
.PP
Everything from the first non-whitespace character after the separator,
up to the end of the line, is treated as the value for the config variable.
So all of the above examples define the same three values: \f(CW\*(AqGeorge\*(Aq\fR,
\&\f(CW\*(Aq47\*(Aq\fR, and \f(CW\*(Aq185\*(Aq\fR.
.PP
In other words, any whitespace immediately surrounding the separator
character is part of the separator, not part of the key or value.
.PP
Note that you can't put a comment on the same line as a configuration
variable. The \f(CW\*(C`# etc.\*(C'\fR is simply considered part of the value:
.PP
.Vb 1
\&    [Delimiters]
\&
\&    block delims:    { }
\&    string delims:   " "
\&    comment delims:  # \en
.Ve
.PP
You can comment a config var on the preceding or succeeding line:
.PP
.Vb 1
\&    [Delimiters]
\&
\&    # Use braces to delimit blocks...
\&    block delims:    { }
\&
\&    # Use double quotes to delimit strings
\&
\&    string delims:   " "
\&
\&    # Use octothorpe/newline to delimit comments
\&    comment delims:  # \en
.Ve
.PP
\fIMulti-line configuration values\fR
.IX Subsection "Multi-line configuration values"
.PP
A single value can be continued over two or more lines. If the line
immediately after a configuration variable starts with the separator
character used in the variable's definition, then the value of the
variable continues on that line. For example:
.PP
.Vb 3
\&    address: 742 Evergreen Terrace
\&           : Springfield
\&           : USA
.Ve
.PP
The newlines then form part of the value, so the value specified in the
previous example is: \f(CW"742\ Evergreen\ Terrace\enSpringfield\enUSA"\fR
.PP
Note that the second and subsequent lines of a continued value are considered
to start where the whitespace after the \fIoriginal\fR separator finished, not
where the whitespace after their own separator finishes. For example, if the
previous example had been:
.PP
.Vb 3
\&    address: 742 Evergreen Terrace
\&           :   Springfield
\&           :     USA
.Ve
.PP
then the value would be:
.PP
.Vb 1
\&    "742 Evergreen Terrace\en  Springfield\en    USA"
.Ve
.PP
If a continuation line has less leading whitespace that the first line:
.PP
.Vb 3
\&    address:   742 Evergreen Terrace
\&           :  Springfield
\&           : USA
.Ve
.PP
it's treated as having no leading whitespace:
.PP
.Vb 1
\&    "742 Evergreen Terrace\enSpringfield\enUSA"
.Ve
.PP
\fIMulti-part configuration values\fR
.IX Subsection "Multi-part configuration values"
.PP
If the particular key appears more than once in the same section, it is
considered to be part of the same configuration variable. The value of
that configuration value is then a list, containing all the individual
values for each instance of the key. For example, given the definition:
.PP
.Vb 5
\&    cast: Homer
\&    cast: Marge
\&    cast: Lisa
\&    cast: Bart
\&    cast: Maggie
.Ve
.PP
the corresponding value of the \f(CW\*(Aqcast\*(Aq\fR configuration variable is:
\&\f(CW\*(C`[\*(AqHomer\*(Aq,\ \*(AqMarge\*(Aq,\ \*(AqLisa\*(Aq,\ \*(AqBart\*(Aq,\ \*(AqMaggie\*(Aq]\*(C'\fR
.PP
Individual values in a multi-part list can also be multi-line (see
above). For example, given:
.PP
.Vb 2
\&    extras: Moe
\&          : (the bartender)
\&
\&    extras: Smithers
\&          : (the dogsbody)
.Ve
.PP
the value for the \f(CW\*(Aqextras\*(Aq\fR config variable is:
\&\f(CW\*(C`["Moe\en(the\ bartender)",\ "Smithers\en(the\ dogsbody)"]\*(C'\fR
.SS "Internal representation"
.IX Subsection "Internal representation"
Each section label in a configuration file becomes a top-level hash key whe
the configuration file is read in. The corresponding value is a nested hash
reference.
.PP
Each configuration variable's key becomes a key in that nested hash reference.
Each configuration variable's value becomes the corresponding value in that nested hash reference.
.PP
Single-line and multi-line values become strings. Multi-part values become
references to arrays of strings.
.PP
For example, the following configuration file:
.PP
.Vb 2
\&    # A simple key (just an identifier)...
\&    simple : simple value
\&
\&    # A more complex key (with whitespace)...
\&    more complex key : more complex value
\&
\&    # A new section...
\&    [MULTI\-WHATEVERS]
\&
\&    # A value spread over several lines...
\&    multi\-line : this is line 1
\&               : this is line 2
\&               : this is line 3
\&
\&    # Several values for the same key...
\&    multi\-value: this is value 1
\&    multi\-value: this is value 2
\&    multi\-value: this is value 3
.Ve
.PP
would be read into a hash whose internal structure looked like this:
.PP
.Vb 6
\&    {
\&       # Default section...
\&       \*(Aq\*(Aq => {
\&          \*(Aqsimple\*(Aq           => \*(Aqsimple value\*(Aq,
\&          \*(Aqmore complex key\*(Aq => \*(Aqmore complex value\*(Aq,
\&       },
\&
\&       # Named section...
\&       \*(AqMULTI\-WHATEVERS\*(Aq => {
\&            \*(Aqmulti\-line\*(Aq  => "this is line 1\enthis is line 2\enthis is line 3",
\&
\&            \*(Aqmulti\-value\*(Aq => [ \*(Aqthis is value 1\*(Aq,
\&                               \*(Aqthis is value 2\*(Aq,
\&                               \*(Aqthis is value 3\*(Aq
\&                             ],
\&        }
\&    }
.Ve
.SH "INTERFACE"
.IX Header "INTERFACE"
The following subroutines are exported automatically whenever the module is
loaded...
.ie n .IP """read_config($filename => %config_hash)""" 4
.el .IP "\f(CWread_config($filename => %config_hash)\fR" 4
.IX Item "read_config($filename => %config_hash)"
.PD 0
.ie n .IP """read_config($filename => $config_hash_ref)""" 4
.el .IP "\f(CWread_config($filename => $config_hash_ref)\fR" 4
.IX Item "read_config($filename => $config_hash_ref)"
.ie n .IP """read_config($string_ref => %config_hash_or_ref)""" 4
.el .IP "\f(CWread_config($string_ref => %config_hash_or_ref)\fR" 4
.IX Item "read_config($string_ref => %config_hash_or_ref)"
.PD
The \f(CW\*(C`read_config()\*(C'\fR subroutine takes two arguments: the filename of a
configuration file, and a variable into which the contents of that
configuration file are to be loaded.
.Sp
If the variable is a hash, then the configuration sections and their
key/value pairs are loaded into nested subhashes of the hash.
.Sp
If the variable is a scalar with an undefined value, a reference to an
anonymous hash is first assigned to that scalar, and that hash is then
filled as described above.
.Sp
The subroutine returns true on success, and throws an exception on failure.
.Sp
If you pass a reference to the string as the first argument to
\&\f(CW\*(C`read_config()\*(C'\fR it uses that string as the source of the config info.
For example:
.Sp
.Vb 1
\&        use Config::Std;
\&
\&        # here we load the config text to a scalar
\&        my $cfg = q{
\&        [Section 1]
\&        attr1 = at
\&        attr2 = bat
\&
\&        [Section 2]
\&        attr3 = cat
\&        };
\&
\&        # here we parse the config from that scalar by passing a reference to it.
\&        read_config( \e$cfg, my %config );
\&
\&        use Data::Dumper \*(AqDumper\*(Aq;
\&        warn Dumper [ \e%config ];
.Ve
.ie n .IP """write_config(%config_hash => $filename)""" 4
.el .IP "\f(CWwrite_config(%config_hash => $filename)\fR" 4
.IX Item "write_config(%config_hash => $filename)"
.PD 0
.ie n .IP """write_config($config_hash_ref => $filename)""" 4
.el .IP "\f(CWwrite_config($config_hash_ref => $filename)\fR" 4
.IX Item "write_config($config_hash_ref => $filename)"
.ie n .IP """write_config(%config_hash)""" 4
.el .IP "\f(CWwrite_config(%config_hash)\fR" 4
.IX Item "write_config(%config_hash)"
.ie n .IP """write_config($config_hash_ref)""" 4
.el .IP "\f(CWwrite_config($config_hash_ref)\fR" 4
.IX Item "write_config($config_hash_ref)"
.PD
The \f(CW\*(C`write_config()\*(C'\fR subroutine takes two arguments: the hash or hash
reference containing the configuration data to be written out to disk,
and an optional filename specifying which file it is to be written to.
.Sp
The data hash must conform to the two-level structure described earlier:
with top-level keys naming sections and their values being references to
second-level hashes that store the keys and values of the configuartion
variables. If the structure of the hash differs from this, an exception is
thrown.
.Sp
If a filename is also specified, the subroutine opens that file
and writes to it. It no filename is specified, the subroutine uses the
name of the file from which the hash was originally loaded using
\&\f(CW\*(C`read_config()\*(C'\fR. It no filename is specified and the hash \fIwasn't\fR
originally loaded using \f(CW\*(C`read_config()\*(C'\fR, an exception is thrown.
.Sp
The subroutine returns true on success and throws and exception on failure.
.PP
If necessary (typically to avoid conflicts with other modules), you can
have the module export its two subroutines with different names by
loading it with the appropriate options:
.PP
.Vb 1
\&    use Config::Std { read_config => \*(Aqget_ini\*(Aq, write_config => \*(Aqupdate_ini\*(Aq };
\&
\&    # and later...
\&
\&    get_ini($filename => %config_hash);
\&
\&    # and later still...
\&
\&    update_ini(%config_hash);
.Ve
.PP
You can also control how much spacing the module puts between single\-
line values when they are first written to a file, by using the
\&\f(CW\*(C`def_gap\*(C'\fR option:
.PP
.Vb 2
\&    # No empty line between single\-line config values...
\&    use Config::Std { def_gap => 0 }; 
\&
\&    # An empty line between all single\-line config values...
\&    use Config::Std { def_gap => 1 };
.Ve
.PP
Regardless of the value passed for \f(CW\*(C`def_gap\*(C'\fR, new multi-line values are
always written with an empty line above and below them. Likewise, values
that were previously read in from a file are always written back with
whatever spacing they originally had.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Can't open config file '%s' (%s)" 4
.IX Item "Can't open config file '%s' (%s)"
You tried to read in a configuration file, but the file you specified
didn't exist. Perhaps the filepath you specified was wrong. Or maybe 
your application didn't have permission to access the file you specified.
.IP "Can't read from locked config file '$filename'" 4
.IX Item "Can't read from locked config file '$filename'"
You tried to read in a configuration file, but the file you specified
was being written by someone else (they had a file lock active on it).
Either try again later, or work out who else is using the file.
.IP "Scalar second argument to 'read_config' must be empty" 4
.IX Item "Scalar second argument to 'read_config' must be empty"
You passed a scalar variable as the destination into \f(CW\*(C`read_config()\*(C'\fR
was supposed to load a configuration file, but that variable already had
a defined value, so \f(CW\*(C`read_config()\*(C'\fR couldn't autovivify a new hash for
you. Did you mean to pass the subroutine a hash instead of a scalar?
.ie n .IP "Can't save %s value for key '%s' (only scalars or array refs)" 4
.el .IP "Can't save \f(CW%s\fR value for key '%s' (only scalars or array refs)" 4
.IX Item "Can't save %s value for key '%s' (only scalars or array refs)"
You called \f(CW\*(C`write_config\*(C'\fR and passed it a hash containing a
configuration variable whose value wasn't a single string, or a list of
strings. The configuration file format supported by this module only
supports those two data types as values. If you really need to store
other kinds of data in a configuration file, you should consider using
\&\f(CW\*(C`Data::Dumper\*(C'\fR or \f(CW\*(C`YAML\*(C'\fR instead.
.IP "Missing filename in call to \fIwrite_config()\fR" 4
.IX Item "Missing filename in call to write_config()"
You tried to calll \f(CW\*(C`write_config()\*(C'\fR with only a configuration hash, but that
hash wasn't originally loaded using \f(CW\*(C`read_config()\*(C'\fR, so \f(CW\*(C`write_config()\*(C'\fR has
no idea where to write it to. Either make sure the hash you're trying to save
was originally loaded using \f(CW\*(C`read_config()\*(C'\fR, or else provide an explicit
filename as the second argument to \f(CW\*(C`write_config()\*(C'\fR.
.IP "Can't open config file '%s' for writing (%s)" 4
.IX Item "Can't open config file '%s' for writing (%s)"
You tried to update or create a configuration file, but the file you
specified could not be opened for writing (for the reason given in the
parentheses). This is often caused by incorrect filepaths or lack of
write permissions on a directory.
.IP "Can't write to locked config file '%s'" 4
.IX Item "Can't write to locked config file '%s'"
You tried to update or create a configuration file, but the file you
specified was being written at the time by someone else (they had a file
lock active on it). Either try again later, or work out who else is
using the file.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Config::Std requires no configuration files or environment variables.
(To do so would be disturbingly recursive.)
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
This module requires the Class::Std module (available from the \s-1CPAN\s0)
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
Those variants of \s-1INI\s0 file dialect supporting partial-line comment are incompatible. 
(This is the price of keeping comments when re-writing.)
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.IP "Loading on demand" 4
.IX Item "Loading on demand"
If you attempt to load \f(CW\*(C`read_config()\*(C'\fR and \f(CW\*(C`write_config()\*(C'\fR 
at runtime with \f(CW\*(C`require\*(C'\fR, you can not rely upon the prototype
to convert a regular hash to a reference. To work around this, 
you must explicitly pass a reference to the config hash.
.Sp
.Vb 2
\&    require Config::Std;
\&    Config::Std\->import;
\&
\&    my %config;
\&    read_config($file, \e%config);
\&    write_config(\e%config, $file);
.Ve
.IP "Windows line endings on Unix/Linux (RT#21547/23550)" 4
.IX Item "Windows line endings on Unix/Linux (RT#21547/23550)"
If the config file being read contains carriage returns and line feeds
at the end of each line rather than just line feeds (i.e. the standard
Windows file format, when read on a machine expecting \s-1POSIX\s0 file format),
Config::Std emits an error with embedded newline.
.Sp
Workaround is match file line-endings to locale.
.Sp
This will be fixed in 1.000.
.IP "leading comment vanishes (RT#24597,)" 4
.IX Item "leading comment vanishes (RT#24597,)"
A comment before the first section is not always retained on write-back, if the '' default section is empty.
.IP "00write.t test 5 fails on perl5.8.1 (RT#17425)" 4
.IX Item "00write.t test 5 fails on perl5.8.1 (RT#17425)"
Due to an incompatible change in v5.8.1 partially reversed in v5.8.2, hash key randomisation can cause test to fail in that one version of Perl. Workaround is export environment variable PERL_HASH_SEED=0.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-config\-std@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@cpan.org>\*(C'\fR
Maintainers 
Bill Ricker    \f(CW\*(C`<BRICKER@cpan.org>\*(C'\fR
Tom Metro      \f(CW\*(C`<tmetro@cpan.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2005, Damian Conway \f(CW\*(C`<DCONWAY@cpan.org>\*(C'\fR. 
Copyright (c) 2011, D.Conway, W.Ricker \f(CW\*(C`<BRICKER@cpan.org>\*(C'\fR All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
