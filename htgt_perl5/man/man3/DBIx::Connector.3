.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Connector 3"
.TH DBIx::Connector 3 "2013-07-25" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
DBIx::Connector \- Fast, safe \s-1DBI\s0 connection and transaction management
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use DBIx::Connector;
\&
\&  # Create a connection.
\&  my $conn = DBIx::Connector\->new($dsn, $username, $password, {
\&      RaiseError => 1,
\&      AutoCommit => 1,
\&  });
\&
\&  # Get the database handle and do something with it.
\&  my $dbh  = $conn\->dbh;
\&  $dbh\->do(\*(AqINSERT INTO foo (name) VALUES (?)\*(Aq, undef, \*(AqFred\*(Aq );
\&
\&  # Do something with the handle more efficiently.
\&  $conn\->run(fixup => sub {
\&      $_\->do(\*(AqINSERT INTO foo (name) VALUES (?)\*(Aq, undef, \*(AqFred\*(Aq );
\&  });
.Ve
.SH "Description"
.IX Header "Description"
DBIx::Connector provides a simple interface for fast and safe \s-1DBI\s0 connection
and transaction management. Connecting to a database can be expensive; you
don't want your application to re-connect every time you need to run a query.
The efficient thing to do is to hang on to a database handle to maintain a
connection to the database in order to minimize that overhead. DBIx::Connector
lets you do that without having to worry about dropped or corrupted
connections.
.PP
You might be familiar with Apache::DBI and with the \s-1DBI\s0's
\&\f(CW\*(C`connect_cached()\*(C'\fR constructor. DBIx::Connector serves
a similar need, but does a much better job. How is it different? I'm glad you
asked!
.IP "\(bu" 4
Fork Safety
.Sp
Like Apache::DBI, but unlike \f(CW\*(C`connect_cached()\*(C'\fR, DBIx::Connector create a new
database connection if a new process has been \f(CW\*(C`fork\*(C'\fRed. This happens all the
time under mod_perl, in \s-1POE\s0 applications, and elsewhere. Works best with
\&\s-1DBI 1.614\s0 and higher.
.IP "\(bu" 4
Thread Safety
.Sp
Unlike Apache::DBI or \f(CW\*(C`connect_cached()\*(C'\fR, DBIx::Connector will create a new
database connection if a new thread has been spawned. As with \f(CW\*(C`fork\*(C'\fRing,
spawning a new thread can break database connections.
.IP "\(bu" 4
Works Anywhere
.Sp
Unlike Apache::DBI, DBIx::Connector runs anywhere \*(-- inside of mod_perl or
not. Why limit yourself?
.IP "\(bu" 4
Explicit Interface
.Sp
DBIx::Connector has an explicit interface. There is none of the magical
action-at-a-distance crap that Apache::DBI is guilty of, and no global
caching. I've personally diagnosed a few issues with Apache::DBI's magic, and
killed it off in two different projects in favor of \f(CW\*(C`connect_cached()\*(C'\fR, only
to be tripped up by other gotchas. No more.
.IP "\(bu" 4
Optimistic Execution
.Sp
If you use \f(CW\*(C`run()\*(C'\fR and \f(CW\*(C`txn()\*(C'\fR, the database handle will be passed without
first pinging the server. For the 99% or more of the time when the database is
just there, you'll save a ton of overhead without the ping.
.PP
DBIx::Connector's other feature is transaction management. Borrowing an
interface from DBIx::Class, DBIx::Connector offers an \s-1API\s0 that efficiently
handles the scoping of database transactions so that you needn't worry about
managing the transaction yourself. Even better, it offers an \s-1API\s0 for
savepoints if your database supports them. Within a transaction, you can scope
savepoints to behave like subtransactions, so that you can save some of your
work in a transaction even if part of it fails. See \f(CW\*(C`txn()\*(C'\fR and
\&\f(CW\*(C`svp()\*(C'\fR for the goods.
.SH "Usage"
.IX Header "Usage"
Unlike Apache::DBI and \f(CW\*(C`connect_cached()\*(C'\fR,
DBIx::Connector doesn't cache database handles. Rather, for a given
connection, it makes sure that the connection is just there whenever you want
it, to the extent possible. The upshot is that it's safe to create a
connection and then keep it around for as long as you need it, like so:
.PP
.Vb 1
\&  my $conn = DBIx::Connector\->new(@args);
.Ve
.PP
You can store the connection somewhere in your app where you can easily access
it, and for as long as it remains in scope, it will try its hardest to
maintain a database connection. Even across \f(CW\*(C`fork\*(C'\fRs (especially with \s-1DBI
1.614\s0 and higher) and new threads, and even calls to
\&\f(CW\*(C`$conn\->dbh\->disconnect\*(C'\fR. When you don't need it anymore, let it go out
of scope and the database connection will be closed.
.PP
The upshot is that your code is responsible for hanging onto a connection for
as long as it needs it. There is no magical connection caching like in
Apache::DBI and \f(CW\*(C`connect_cached()\*(C'\fR.
.SS "Execution Methods"
.IX Subsection "Execution Methods"
The real utility of DBIx::Connector comes from the use of the execution
methods, \f(CW\*(C`run()\*(C'\fR, \f(CW\*(C`txn()\*(C'\fR, or \f(CW\*(C`svp()\*(C'\fR.
Instead of this:
.PP
.Vb 1
\&  $conn\->dbh\->do($query);
.Ve
.PP
Try this:
.PP
.Vb 1
\&  $conn\->run(sub { $_\->do($query) }); # returns retval from the sub {...}
.Ve
.PP
The difference is that the \f(CW\*(C`run()\*(C'\fR optimistically assumes that an existing
database handle is connected and executes the code reference without pinging
the database. The vast majority of the time, the connection will of course
still be open. You therefore save the overhead of a ping query every time you
use \f(CW\*(C`run()\*(C'\fR (or \f(CW\*(C`txn()\*(C'\fR).
.PP
Of course, if a block passed to \f(CW\*(C`run()\*(C'\fR dies because the \s-1DBI\s0 isn't actually
connected to the database you'd need to catch that failure and try again.
DBIx::Connector provides a way to overcome this issue: connection modes.
.PP
\fIConnection Modes\fR
.IX Subsection "Connection Modes"
.PP
When calling \f(CW\*(C`run()\*(C'\fR, \f(CW\*(C`txn()\*(C'\fR, or \f(CW\*(C`svp()\*(C'\fR,
each executes within the context of a \*(L"connection mode.\*(R" The supported modes
are:
.IP "\(bu" 4
\&\f(CW\*(C`ping\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`fixup\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`no_ping\*(C'\fR
.PP
Use them via an optional first argument, like so:
.PP
.Vb 1
\&  $conn\->run(ping => sub { $_\->do($query) });
.Ve
.PP
Or set up a default mode via the \f(CW\*(C`mode()\*(C'\fR accessor:
.PP
.Vb 2
\&  $conn\->mode(\*(Aqfixup\*(Aq);
\&  $conn\->run(sub { $_\->do($query) });
.Ve
.PP
The return value of the block will be returned from the method call in scalar
or array context as appropriate, and the block can use \f(CW\*(C`wantarray\*(C'\fR to
determine the context. Returning the value makes them handy for things like
constructing a statement handle:
.PP
.Vb 5
\&  my $sth = $conn\->run(fixup => sub {
\&      my $sth = $_\->prepare(\*(AqSELECT isbn, title, rating FROM books\*(Aq);
\&      $sth\->execute;
\&      $sth;
\&  });
.Ve
.PP
In \f(CW\*(C`ping\*(C'\fR mode, \f(CW\*(C`run()\*(C'\fR will ping the database \fIbefore\fR running the block.
This is similar to what Apache::DBI and the \s-1DBI\s0's
\&\f(CW\*(C`connect_cached()\*(C'\fR method do to check the database
connection, and is the safest way to do so. If the ping fails, DBIx::Connector
will attempt to reconnect to the database before executing the block. However,
\&\f(CW\*(C`ping\*(C'\fR mode does impose the overhead of the \f(CW\*(C`ping\*(C'\fR ever time you use it.
.PP
In \f(CW\*(C`fixup\*(C'\fR mode, DBIx::Connector executes the block without pinging the
database. But in the event the block throws an exception, if DBIx::Connector
finds that the database handle is no longer connected, it will reconnect to
the database and re-execute the block. Therefore, the code reference should
have \fBno side-effects outside of the database,\fR as double-execution in the
event of a stale database connection could break something:
.PP
.Vb 3
\&  my $count;
\&  $conn\->run(fixup => sub { $count++ });
\&  say $count; # may be 1 or 2
.Ve
.PP
\&\f(CW\*(C`fixup\*(C'\fR is the most efficient connection mode. If you're confident that the
block will have no deleterious side-effects if run twice, this is the best
option to choose. If you decide that your block is likely to have too many
side-effects to execute more than once, you can simply switch to \f(CW\*(C`ping\*(C'\fR mode.
.PP
The default is \f(CW\*(C`no_ping\*(C'\fR, but you likely won't ever use it directly, and
isn't recommended in any event.
.PP
Simple, huh? Better still, go for the transaction management in
\&\f(CW\*(C`txn()\*(C'\fR and the savepoint management in \f(CW\*(C`svp()\*(C'\fR. You
won't be sorry, I promise.
.PP
\fIRollback Exceptions\fR
.IX Subsection "Rollback Exceptions"
.PP
In the event of a rollback in \f(CW\*(C`txn()\*(C'\fR or \f(CW\*(C`svp()\*(C'\fR, if the
rollback itself fails, a DBIx::Connector::TxnRollbackError or
DBIx::Connector::SvpRollbackError exception will be thrown, as appropriate.
These classes, which inherit from DBIx::Connector::RollbackError, stringify to
display both the rollback error and the transaction or savepoint error that
led to the rollback, something like this:
.PP
.Vb 2
\&    Transaction aborted: No such table "foo" at foo.pl line 206.
\&    Transaction rollback failed: Invalid transaction ID at foo.pl line 203.
.Ve
.PP
For finer-grained exception handling, you can access the individual errors via
accessors:
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
The transaction or savepoint error.
.ie n .IP """rollback_error""" 4
.el .IP "\f(CWrollback_error\fR" 4
.IX Item "rollback_error"
The rollback error.
.PP
For example:
.PP
.Vb 10
\&  use Try::Tiny;
\&  $conn\->txn(sub {
\&      try {
\&          # ...
\&      } catch {
\&          if (eval { $_\->isa(\*(AqDBIx::Connector::RollbackError\*(Aq) }) {
\&              say STDERR \*(AqTransaction aborted: \*(Aq, $_\->error;
\&              say STDERR \*(AqRollback failed too: \*(Aq, $_\->rollback_error;
\&          } else {
\&              warn "Caught exception: $_";
\&          }
\&      };
\&  });
.Ve
.PP
If a \f(CW\*(C`svp()\*(C'\fR rollback fails and its surrounding \f(CW\*(C`txn()\*(C'\fR
rollback \fIalso\fR fails, the thrown DBIx::Connetor::TxnRollbackError exception
object will have the the savepoint rollback exception, which will be an
DBIx::Connetor::SvpRollbackError exception object in its \f(CW\*(C`error\*(C'\fR attribute:
.PP
.Vb 10
\&  use Try::Tiny;
\&  $conn\->txn(sub {
\&      try {
\&          $conn\->svp(sub { # ... });
\&      } catch {
\&          if (eval { $_\->isa(\*(AqDBIx::Connector::RollbackError\*(Aq) }) {
\&              if (eval { $_\->error\->isa(\*(AqDBIx::Connector::SvpRollbackError\*(Aq) }) {
\&                  say STDERR \*(AqSavepoint aborted: \*(Aq, $_\->error\->error;
\&                  say STDERR \*(AqIts rollback failed too: \*(Aq, $_\->error\->rollback_error;
\&              } else {
\&                  say STDERR \*(AqTransaction aborted: \*(Aq, $_\->error;
\&              }
\&              say STDERR \*(AqTransaction rollback failed too: \*(Aq, $_\->rollback_error;
\&          } else {
\&              warn "Caught exception: $_";
\&          }
\&      };
\&  });
.Ve
.PP
But most of the time, you should be fine with the stringified form of the
exception, which will look something like this:
.PP
.Vb 3
\&    Transaction aborted: Savepoint aborted: No such table "bar" at foo.pl line 190.
\&    Savepoint rollback failed: Invalid savepoint name at foo.pl line 161.
\&    Transaction rollback failed: Invalid transaction identifier at fool.pl line 184.
.Ve
.PP
This allows you to see you original \s-1SQL\s0 error, as well as the errors for the
savepoint rollback and transaction rollback failures.
.SH "Interface"
.IX Header "Interface"
And now for the nitty-gritty.
.SS "Constructor"
.IX Subsection "Constructor"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 4
\&  my $conn = DBIx::Connector\->new($dsn, $username, $password, {
\&      RaiseError => 1,
\&      AutoCommit => 1,
\&  });
.Ve
.PP
Constructs and returns a DBIx::Connector object. The supported arguments are
exactly the same as those supported by the \s-1DBI\s0. Default values for those
parameters vary from the \s-1DBI\s0 as follows:
.ie n .IP """RaiseError""" 4
.el .IP "\f(CWRaiseError\fR" 4
.IX Item "RaiseError"
Defaults to true if unspecified, and if \f(CW\*(C`HandleError\*(C'\fR is unspecified. Use of
the \f(CW\*(C`RaiseError\*(C'\fR attribute, or a \f(CW\*(C`HandleError\*(C'\fR attribute that always throws
exceptions (such as that provided by Exception::Class::DBI), is required
for the exception-handling functionality of \f(CW\*(C`run()\*(C'\fR,
\&\f(CW\*(C`txn()\*(C'\fR, and \f(CW\*(C`svp()\*(C'\fR to work properly. Their explicit
use is therefor recommended if for proper error handling with these execution
methods.
.ie n .IP """AutoInactiveDestroy""" 4
.el .IP "\f(CWAutoInactiveDestroy\fR" 4
.IX Item "AutoInactiveDestroy"
Added in \s-1DBI\s0 1.613. Defaults to true if unspecified. This is important for
safe disconnects across forking processes.
.PP
In addition, explicitly setting \f(CW\*(C`AutoCommit\*(C'\fR to true is strongly recommended
if you plan to use \f(CW\*(C`txn()\*(C'\fR or \f(CW\*(C`svp()\*(C'\fR, as otherwise you
won't get the transactional scoping behavior of those two methods.
.PP
If you would like to execute custom logic each time a new connection to the
database is made you can pass a sub as the \f(CW\*(C`connected\*(C'\fR key to the
\&\f(CW\*(C`Callbacks\*(C'\fR parameter. See \*(L"Callbacks\*(R" in \s-1DBI\s0 for usage and other available
callbacks.
.PP
Other attributes may be modified by individual drivers. See the documentation
for the drivers for details:
.IP "DBIx::Connector::Driver::MSSQL" 4
.IX Item "DBIx::Connector::Driver::MSSQL"
.PD 0
.IP "DBIx::Connector::Driver::Oracle" 4
.IX Item "DBIx::Connector::Driver::Oracle"
.IP "DBIx::Connector::Driver::Pg" 4
.IX Item "DBIx::Connector::Driver::Pg"
.IP "DBIx::Connector::Driver::SQLite" 4
.IX Item "DBIx::Connector::Driver::SQLite"
.IP "DBIx::Connector::Driver::mysql" 4
.IX Item "DBIx::Connector::Driver::mysql"
.PD
.SS "Class Method"
.IX Subsection "Class Method"
\fI\f(CI\*(C`connect\*(C'\fI\fR
.IX Subsection "connect"
.PP
.Vb 1
\&  my $dbh = DBIx::Connector\->connect($dsn, $username, $password, \e%attr);
.Ve
.PP
Syntactic sugar for:
.PP
.Vb 1
\&  my $dbh = DBIx::Connector\->new(@args)\->dbh;
.Ve
.PP
Though there's probably not much point in that, as you'll generally want to
hold on to the DBIx::Connector object. Otherwise you'd just use the \s-1DBI\s0,
no?
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`dbh\*(C'\fI\fR
.IX Subsection "dbh"
.PP
.Vb 1
\&  my $dbh = $conn\->dbh;
.Ve
.PP
Returns the connection's database handle. It will use a an existing handle if
there is one, if the process has not been \f(CW\*(C`fork\*(C'\fRed or a new thread spawned,
and if the database is pingable. Otherwise, it will instantiate, cache, and
return a new handle.
.PP
When called from blocks passed to \f(CW\*(C`run()\*(C'\fR, \f(CW\*(C`txn()\*(C'\fR, and
\&\f(CW\*(C`svp()\*(C'\fR, \f(CW\*(C`dbh()\*(C'\fR assumes that the pingability of the database is
handled by those methods and skips the \f(CW\*(C`ping()\*(C'\fR. Otherwise, it performs all
the same validity checks. The upshot is that it's safe to call \f(CW\*(C`dbh()\*(C'\fR inside
those blocks without the overhead of multiple \f(CW\*(C`ping\*(C'\fRs. Indeed, it's
preferable to do so if you're doing lots of non-database processing in those
blocks.
.PP
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
.Vb 1
\&  $conn\->run(ping => sub { $_\->do($query) });
.Ve
.PP
Simply executes the block, setting \f(CW$_\fR to and passing in the database
handle. Returns the value returned by the block in scalar or array context as
appropriate (and the block can use \f(CW\*(C`wantarray\*(C'\fR to decide what to do).
.PP
An optional first argument sets the connection mode, overriding that set in
the \f(CW\*(C`mode()\*(C'\fR accessor, and may be one of \f(CW\*(C`ping\*(C'\fR, \f(CW\*(C`fixup\*(C'\fR, or \f(CW\*(C`no_ping\*(C'\fR
(the default). See \*(L"Connection Modes\*(R" for further explication.
.PP
For convenience, you can nest calls to \f(CW\*(C`run()\*(C'\fR (or \f(CW\*(C`txn()\*(C'\fR or \f(CW\*(C`svp()\*(C'\fR),
although the connection mode will be invoked to check the connection (or not)
only in the outer-most block method call.
.PP
.Vb 10
\&  $conn\->txn(fixup => sub {
\&      my $dbh = shift;
\&      $dbh\->do($_) for @queries;
\&      $conn\->run(sub {
\&          $_\->do($expensive_query);
\&          $conn\->txn(sub {
\&              $_\->do($another_expensive_query);
\&          });
\&      });
\&  });
.Ve
.PP
All code executed inside the top-level call to \f(CW\*(C`txn()\*(C'\fR will be executed in a
single transaction. If you'd like subtransactions, nest \f(CW\*(C`svp()\*(C'\fR
calls.
.PP
It's preferable to use \f(CW\*(C`dbh()\*(C'\fR to fetch the database handle from within the
block if your code is doing lots of non-database stuff (shame on you!):
.PP
.Vb 4
\&  $conn\->run(ping => sub {
\&      parse_gigabytes_of_xml(); # Get this out of the transaction!
\&      $conn\->dbh\->do($query);
\&  });
.Ve
.PP
This is because \f(CW\*(C`dbh()\*(C'\fR will better ensure that the database handle is active
and \f(CW\*(C`fork\*(C'\fR\- and thread-safe, although it will never \f(CW\*(C`ping()\*(C'\fR the database
when called from inside a \f(CW\*(C`run()\*(C'\fR, \f(CW\*(C`txn()\*(C'\fR or \f(CW\*(C`svp()\*(C'\fR block.
.PP
\fI\f(CI\*(C`txn\*(C'\fI\fR
.IX Subsection "txn"
.PP
.Vb 1
\&  my $sth = $conn\->txn(fixup => sub { $_\->do($query) });
.Ve
.PP
Starts a transaction, executes the block, setting \f(CW$_\fR to and passing in the
database handle, and commits the transaction. If the block throws an
exception, the transaction will be rolled back and the exception re-thrown.
Returns the value returned by the block in scalar or array context as
appropriate (and the block can use \f(CW\*(C`wantarray\*(C'\fR to decide what to do).
.PP
An optional first argument sets the connection mode, overriding that set in
the \f(CW\*(C`mode()\*(C'\fR accessor, and may be one of \f(CW\*(C`ping\*(C'\fR, \f(CW\*(C`fixup\*(C'\fR, or \f(CW\*(C`no_ping\*(C'\fR
(the default). In the case of \f(CW\*(C`fixup\*(C'\fR mode, this means that the transaction
block will be re-executed for a new connection if the database handle is no
longer connected. In such a case, a second exception from the code block will
cause the transaction to be rolled back and the exception re-thrown. See
\&\*(L"Connection Modes\*(R" for further explication.
.PP
As with \f(CW\*(C`run()\*(C'\fR, calls to \f(CW\*(C`txn()\*(C'\fR can be nested, although the connection
mode will be invoked to check the connection (or not) only in the outer-most
block method call. It's preferable to use \f(CW\*(C`dbh()\*(C'\fR to fetch the database
handle from within the block if your code is doing lots of non-database
processing.
.PP
\fI\f(CI\*(C`svp\*(C'\fI\fR
.IX Subsection "svp"
.PP
Executes a code block within the scope of a database savepoint if your
database supports them. Returns the value returned by the block in scalar or
array context as appropriate (and the block can use \f(CW\*(C`wantarray\*(C'\fR to decide
what to do).
.PP
You can think of savepoints as a kind of subtransaction. What this means is
that you can nest your savepoints and recover from failures deeper in the nest
without throwing out all changes higher up in the nest. For example:
.PP
.Vb 12
\&  $conn\->txn(fixup => sub {
\&      my $dbh = shift;
\&      $dbh\->do(\*(AqINSERT INTO table1 VALUES (1)\*(Aq);
\&      eval {
\&          $conn\->svp(sub {
\&              shift\->do(\*(AqINSERT INTO table1 VALUES (2)\*(Aq);
\&              die \*(AqOMGWTF?\*(Aq;
\&          });
\&      };
\&      warn "Savepoint failed\en" if $@;
\&      $dbh\->do(\*(AqINSERT INTO table1 VALUES (3)\*(Aq);
\&  });
.Ve
.PP
This transaction will insert the values 1 and 3, but not 2.
.PP
.Vb 7
\&  $conn\->svp(fixup => sub {
\&      my $dbh = shift;
\&      $dbh\->do(\*(AqINSERT INTO table1 VALUES (4)\*(Aq);
\&      $conn\->svp(sub {
\&          shift\->do(\*(AqINSERT INTO table1 VALUES (5)\*(Aq);
\&      });
\&  });
.Ve
.PP
This transaction will insert both 4 and 5.
.PP
Superficially, \f(CW\*(C`svp()\*(C'\fR resembles \f(CW\*(C`run()\*(C'\fR and \f(CW\*(C`txn()\*(C'\fR,
including its support for the optional connection mode
argument, but in fact savepoints can only be used within the scope of a
transaction. Thus \f(CW\*(C`svp()\*(C'\fR will start a transaction for you if it's called
without a transaction in-progress. It simply redispatches to \f(CW\*(C`txn()\*(C'\fR with the
appropriate connection mode. Thus, this call from outside of a transaction:
.PP
.Vb 3
\&  $conn\->svp(ping => sub {
\&      $conn\->svp( sub { ... } );
\&  });
.Ve
.PP
Is equivalent to:
.PP
.Vb 3
\&  $conn\->txn(ping => sub {
\&      $conn\->svp( sub { ... } );
\&  })
.Ve
.PP
Savepoints are supported by the following RDBMSs:
.IP "\(bu" 4
PostgreSQL 8.0
.IP "\(bu" 4
SQLite 3.6.8
.IP "\(bu" 4
MySQL 5.0.3 (InnoDB)
.IP "\(bu" 4
Oracle
.IP "\(bu" 4
Microsoft \s-1SQL\s0 Server
.PP
For all other RDBMSs, \f(CW\*(C`svp()\*(C'\fR works just like \f(CW\*(C`txn()\*(C'\fR: savepoints will be
ignored and the outer-most transaction will be the only transaction. This
tends to degrade well for non-savepoint-supporting databases, doing the right
thing in most cases.
.PP
\fI\f(CI\*(C`mode\*(C'\fI\fR
.IX Subsection "mode"
.PP
.Vb 4
\&  my $mode = $conn\->mode;
\&  $conn\->mode(\*(Aqfixup\*(Aq);
\&  $conn\->txn(sub { ... }); # uses fixup mode.
\&  $conn\->mode($mode);
.Ve
.PP
Gets and sets the connection mode attribute, which is
used by \f(CW\*(C`run()\*(C'\fR, \f(CW\*(C`txn()\*(C'\fR, and \f(CW\*(C`svp()\*(C'\fR if no mode is passed to them.
Defaults to \*(L"no_ping\*(R". Note that inside a block passed to \f(CW\*(C`run()\*(C'\fR, \f(CW\*(C`txn()\*(C'\fR,
or \f(CW\*(C`svp()\*(C'\fR, the mode attribute will be set to the optional first parameter:
.PP
.Vb 5
\&  $conn\->mode(\*(Aqping\*(Aq);
\&  $conn\->txn(fixup => sub {
\&      say $conn\->mode; # Outputs "fixup"
\&  });
\&  say $conn\->mode; # Outputs "ping"
.Ve
.PP
In this way, you can reliably tell in what mode the code block is executing.
.PP
\fI\f(CI\*(C`connected\*(C'\fI\fR
.IX Subsection "connected"
.PP
.Vb 3
\&  if ( $conn\->connected ) {
\&      $conn\->dbh\->do($query);
\&  }
.Ve
.PP
Returns true if currently connected to the database and false if it's not. You
probably won't need to bother with this method; DBIx::Connector uses it
internally to determine whether or not to create a new connection to the
database before returning a handle from \f(CW\*(C`dbh()\*(C'\fR.
.PP
\fI\f(CI\*(C`in_txn\*(C'\fI\fR
.IX Subsection "in_txn"
.PP
.Vb 3
\&  if ( $conn\->in_txn ) {
\&     say \*(AqTransacting!\*(Aq;
\&  }
.Ve
.PP
Returns true if the connection is in a transaction. For example, inside a
\&\f(CW\*(C`txn()\*(C'\fR block it would return true. It will also work if you use the \s-1DBI API\s0
to manage transactions (i.e., \f(CW\*(C`begin_work()\*(C'\fR or \f(CW\*(C`AutoCommit\*(C'\fR.
.PP
Essentially, this is just sugar for:
.PP
.Vb 1
\&  $con\->run( no_ping => sub { !$_\->{AutoCommit} } );
.Ve
.PP
But without the overhead of the code reference or connection checking.
.PP
\fI\f(CI\*(C`disconnect_on_destroy\*(C'\fI\fR
.IX Subsection "disconnect_on_destroy"
.PP
.Vb 1
\&  $conn\->disconnect_on_destroy(0);
.Ve
.PP
By default, DBIx::Connector calls \f(CW\*(C`$dbh\->disconnect\*(C'\fR when it goes out of
scope and is garbage-collected by the system (that is, in its \f(CW\*(C`DESTROY()\*(C'\fR
method). Usually this is what you want, but in some cases it might not be. For
example, you might have a module that uses DBIx::Connector internally, but
then makes the database handle available to callers, even after the
DBIx::Connector object goes out of scope. In such a case, you don't want the
database handle to be disconnected when the DBIx::Connector goes out of scope.
So pass a false value to \f(CW\*(C`disconnect_on_destroy\*(C'\fR to prevent the disconnect.
An example:
.PP
.Vb 8
\&  sub database_handle {
\&       my $conn = DBIx::Connector\->new(@_);
\&       $conn\->run(sub {
\&           # Do stuff here.
\&       });
\&       $conn\->disconnect_on_destroy(0);
\&       return $conn\->dbh;
\&  }
.Ve
.PP
Of course, if you don't need to do any work with the database handle before
returning it to your caller, you can just use \f(CW\*(C`connect()\*(C'\fR:
.PP
.Vb 3
\&  sub database_handle {
\&      DBIx::Connector\->connect(@_);
\&  }
.Ve
.PP
\fI\f(CI\*(C`disconnect\*(C'\fI\fR
.IX Subsection "disconnect"
.PP
.Vb 1
\&  $conn\->disconnect;
.Ve
.PP
Disconnects from the database. Unless \f(CW\*(C`disconnect_on_destroy()\*(C'\fR has been
passed a false value, DBIx::Connector uses this method internally in its
\&\f(CW\*(C`DESTROY\*(C'\fR method to make sure that things are kept tidy.
.PP
\fI\f(CI\*(C`driver\*(C'\fI\fR
.IX Subsection "driver"
.PP
.Vb 1
\&  $conn\->driver\->begin_work( $conn\->dbh );
.Ve
.PP
In order to support all database features in a database-neutral way,
DBIx::Connector provides a number of different database drivers, subclasses of
DBIx::Connector::Driver, that offer methods to handle database
communications. Although the \s-1DBI\s0 provides a standard interface, for better
or for worse, not all of the drivers implement them, and some have bugs. To
avoid those issues, all database communications are handled by these driver
objects.
.PP
This can be useful if you want more fine-grained control of your
transactionality. For example, to create your own savepoint within a
transaction, you might do something like this:
.PP
.Vb 12
\&  use Try::Tiny;
\&  my $driver = $conn\->driver;
\&  $conn\->txn(sub {
\&      my $dbh = shift;
\&      try {
\&          $driver\->savepoint($dbh, \*(Aqmysavepoint\*(Aq);
\&          # do stuff ...
\&          $driver\->release(\*(Aqmysavepoint\*(Aq);
\&      } catch {
\&          $driver\->rollback_to($dbh, \*(Aqmysavepoint\*(Aq);
\&      };
\&  });
.Ve
.PP
Most often you should be able to get what you need out of \f(CW\*(C`txn()\*(C'\fR
and \f(CW\*(C`svp()\*(C'\fR, but sometimes you just need the finer control. In
those cases, take advantage of the driver object to keep your use of the \s-1API\s0
universal across database back-ends.
.SH "See Also"
.IX Header "See Also"
.IP "\(bu" 4
DBIx::Connector::Driver
.IP "\(bu" 4
\&\s-1DBI\s0
.IP "\(bu" 4
DBIx::Class
.IP "\(bu" 4
Catalyst::Model::DBI
.SH "Support"
.IX Header "Support"
This module is managed in an open
GitHub repository <http://github.com/theory/dbix-connector/>. Feel free to
fork and contribute, or to clone <git://github.com/theory/dbix\-connector.git>
and send patches!
.PP
Found a bug? Please post <http://github.com/theory/dbix-connector/issues> or
email <mailto:bug-dbix-connector@rt.cpan.org> a report!
.SH "Authors"
.IX Header "Authors"
This module was written and is maintained by:
.IP "\(bu" 4
David E. Wheeler <david@kineticode.com>
.PP
It is based on documentation, ideas, kibbitzing, and code from:
.IP "\(bu" 4
Tim Bunce <http://tim.bunce.name>
.IP "\(bu" 4
Brandon L. Black <blblack@gmail.com>
.IP "\(bu" 4
Matt S. Trout <mst@shadowcat.co.uk>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.IP "\(bu" 4
Ash Berlin <ash@cpan.org>
.IP "\(bu" 4
Rob Kinyon <rkinyon@cpan.org>
.IP "\(bu" 4
Cory G Watson <gphat@cpan.org>
.IP "\(bu" 4
Anders Nor Berle <berle@cpan.org>
.IP "\(bu" 4
John Siracusa <siracusa@gmail.com>
.IP "\(bu" 4
Alex Pavlovic <alex.pavlovic@taskforce\-1.com>
.IP "\(bu" 4
Many other DBIx::Class contributors
.SH "Copyright and License"
.IX Header "Copyright and License"
Copyright (c) 2009\-2010 David E. Wheeler. Some Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
