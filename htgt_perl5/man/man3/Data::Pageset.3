.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Pageset 3"
.TH Data::Pageset 3 "2010-01-03" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Pageset \- Page numbering and page sets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  use Data::Pageset;
\&  my $page_info = Data::Pageset\->new({
\&    \*(Aqtotal_entries\*(Aq       => $total_entries, 
\&    \*(Aqentries_per_page\*(Aq    => $entries_per_page, 
\&    # Optional, will use defaults otherwise.
\&    \*(Aqcurrent_page\*(Aq        => $current_page,
\&    \*(Aqpages_per_set\*(Aq       => $pages_per_set,
\&    \*(Aqmode\*(Aq                => \*(Aqfixed\*(Aq, # default, or \*(Aqslide\*(Aq
\&  });
\&
\&  # General page information
\&  print "         First page: ", $page_info\->first_page, "\en";
\&  print "          Last page: ", $page_info\->last_page, "\en";
\&  print "          Next page: ", $page_info\->next_page, "\en";
\&  print "      Previous page: ", $page_info\->previous_page, "\en";
\&
\&  # Results on current page
\&  print "First entry on page: ", $page_info\->first, "\en";
\&  print " Last entry on page: ", $page_info\->last, "\en";
\&
\&  # Can add in the pages per set after the object is created
\&  $page_info\->pages_per_set($pages_per_set);
\&  
\&  # Page set information
\&  print "First page of previous page set: ",  $page_info\->previous_set, "\en";
\&  print "    First page of next page set: ",  $page_info\->next_set, "\en";
\&  
\&  # Print the page numbers of the current set
\&  foreach my $page (@{$page_info\->pages_in_set()}) {
\&    if($page == $page_info\->current_page()) {
\&      print "<b>$page</b> ";
\&    } else {
\&      print "$page ";
\&    }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The object produced by Data::Pageset can be used to create page
navigation, it inherits from Data::Page and has access to all 
methods from this object.
.PP
In addition it also provides methods for dealing with set of pages,
so that if there are too many pages you can easily break them
into chunks for the user to browse through.
.PP
You can even choose to view page numbers in your set in a 'sliding'
fassion.
.PP
The object can easily be passed to a templating system
such as Template Toolkit or be used within a script.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 9
\&  use Data::Pageset;
\&  my $page_info = Data::Pageset\->new({
\&    \*(Aqtotal_entries\*(Aq       => $total_entries, 
\&    \*(Aqentries_per_page\*(Aq    => $entries_per_page, 
\&    # Optional, will use defaults otherwise.
\&    \*(Aqcurrent_page\*(Aq        => $current_page,
\&    \*(Aqpages_per_set\*(Aq       => $pages_per_set,
\&    \*(Aqmode\*(Aq                => \*(Aqslide\*(Aq, # default fixed
\&  });
.Ve
.PP
This is the constructor of the object, it requires an anonymous
hash containing the 'total_entries', how many data units you have,
and the number of 'entries_per_page' to display. Optionally
the 'current_page' (defaults to page 1) and pages_per_set (how
many pages to display, defaults to 10) can be added.
.PP
The mode (which defaults to 'fixed') determins how the paging
will work, for example with 10 pages_per_set and the current_page
set to 18 you will get the following results:
.PP
\fIFixed:\fR
.IX Subsection "Fixed:"
.IP "Pages in set:" 4
.IX Item "Pages in set:"
11,12,13,14,15,16,17,18,19,20
.IP "Previous page set:" 4
.IX Item "Previous page set:"
1
.IP "Next page set:" 4
.IX Item "Next page set:"
21
.PP
\fISlide:\fR
.IX Subsection "Slide:"
.IP "Pages in set:" 4
.IX Item "Pages in set:"
14,15,16,17,18,19,20,21,22,23
.IP "Previous page set:" 4
.IX Item "Previous page set:"
9
.IP "Next page set:" 4
.IX Item "Next page set:"
24
.PP
You can not change modes once the object is created.
.SS "\fIcurrent_page()\fP"
.IX Subsection "current_page()"
.Vb 1
\&  $page_info\->current_page($page_num);
.Ve
.PP
This method sets the current_page to the argument supplied, it can also be 
set in the constructor, but you may want to reuse the object if printing out
multiple pages. It will then return the page number once set.
.PP
If this method is called without any arguments it returns the current page number.
.SS "\fIpages_per_set()\fP"
.IX Subsection "pages_per_set()"
.Vb 1
\&  $page_info\->pages_per_set($number_of_pages_per_set);
.Ve
.PP
Calling this method initalises the calculations required to use
the paging methods below. The value can also be passed into
the constructor method \fInew()\fR.
.PP
If called without any arguments it will return the current
number of pages per set.
.SS "\fIprevious_set()\fP"
.IX Subsection "previous_set()"
.Vb 1
\&  print "Back to previous set which starts at ", $page_info\->previous_set(), "\en";
.Ve
.PP
This method returns the page number at the start of the previous page set.
undef is return if pages_per_set has not been set.
.SS "\fInext_set()\fP"
.IX Subsection "next_set()"
.Vb 1
\&  print "Next set starts at ", $page_info\->next_set(), "\en";
.Ve
.PP
This method returns the page number at the start of the next page set.
undef is return if pages_per_set has not been set.
.SS "\fIpages_in_set()\fP"
.IX Subsection "pages_in_set()"
.Vb 3
\&  foreach my $page_num (@{$page_info\->pages_in_set()}) {
\&    print "Page: $page_num \en";
\&  }
.Ve
.PP
This method returns an array ref of the the page numbers within
the current set. undef is return if pages_per_set has not been set.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "AUTHOR"
.IX Header "AUTHOR"
Leo Lapworth \f(CW\*(C`<LLAP@cuckoo.org>\*(C'\fR
.SH "REPOSITORY"
.IX Header "REPOSITORY"
http://github.com/ranguard/data\-pageset
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Ryan D Johnson \f(CW\*(C`<ryan@innerfence.com>\*(C'\fR
\&\s-1PLOBBES\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Page.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2007, Leo Lapworth
.PP
This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 112:" 4
.IX Item "Around line 112:"
=back doesn't take any parameters, but you said =back 4
.IP "Around line 130:" 4
.IX Item "Around line 130:"
=back doesn't take any parameters, but you said =back 4
