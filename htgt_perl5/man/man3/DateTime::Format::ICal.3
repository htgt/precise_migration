.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DateTime::Format::ICal 3"
.TH DateTime::Format::ICal 3 "2013-07-25" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DateTime::Format::ICal \- Parse and format iCal datetime and duration strings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DateTime::Format::ICal;
\&
\&  my $dt = DateTime::Format::ICal\->parse_datetime( \*(Aq20030117T032900Z\*(Aq );
\&
\&  my $dur = DateTime::Format::ICal\->parse_duration( \*(Aq+P3WT4H55S\*(Aq );
\&
\&  # 20030117T032900Z
\&  DateTime::Format::ICal\->format_datetime($dt);
\&
\&  # +P3WT4H55S
\&  DateTime::Format::ICal\->format_duration($dur);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module understands the ICal date/time and duration formats, as
defined in \s-1RFC 2445. \s0 It can be used to parse these formats in order
to create the appropriate objects.
.SH "METHODS"
.IX Header "METHODS"
This class offers the following methods.
.IP "\(bu" 4
parse_datetime($string)
.Sp
Given an iCal datetime string, this method will return a new
\&\f(CW\*(C`DateTime\*(C'\fR object.
.Sp
If given an improperly formatted string, this method may die.
.IP "\(bu" 4
parse_duration($string)
.Sp
Given an iCal duration string, this method will return a new
\&\f(CW\*(C`DateTime::Duration\*(C'\fR object.
.Sp
If given an improperly formatted string, this method may die.
.IP "\(bu" 4
parse_period($string)
.Sp
Given an iCal period string, this method will return a new
\&\f(CW\*(C`DateTime::Span\*(C'\fR object.
.Sp
If given an improperly formatted string, this method may die.
.IP "\(bu" 4
parse_recurrence( recurrence => \f(CW$string\fR, ... )
.Sp
Given an iCal recurrence description, this method uses
\&\f(CW\*(C`DateTime::Event::ICal\*(C'\fR to create a \f(CW\*(C`DateTime::Set\*(C'\fR object
representing that recurrence.  Any parameters given to this method
beside \*(L"recurrence\*(R" will be passed directly to the 
\&\f(CW\*(C`DateTime::Event::ICal\->recur\*(C'\fR method.
.Sp
If given an improperly formatted string, this method may die.
.Sp
This method accepts optional parameters \*(L"dtstart\*(R" and \*(L"dtend\*(R".
These parameters must be \f(CW\*(C`DateTime\*(C'\fR objects.
.Sp
The iCal spec requires that \*(L"dtstart\*(R" always be included in the
recurrence set, unless this is an \*(L"exrule\*(R" statement.  Since we don't
know what kind of statement is being parsed, we do not include
\&\f(CW\*(C`dtstart\*(C'\fR in the recurrence set.
.IP "\(bu" 4
format_datetime($datetime)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this methods returns an iCal datetime
string.
.Sp
The iCal spec requires that datetimes be formatted either as floating
times (no time zone), \s-1UTC \s0(with a 'Z' suffix) or with a time zone id
at the beginning ('TZID=America/Chicago;...').  If this method is
asked to format a \f(CW\*(C`DateTime\*(C'\fR object that has an offset-only time
zone, then the object will be converted to the \s-1UTC\s0 time zone
internally before formatting.
.Sp
For example, this code:
.Sp
.Vb 1
\&    my $dt = DateTime\->new( year => 1900, hour => 15, time_zone => \*(Aq\-0100\*(Aq );
\&
\&    print $ical\->format_datetime($dt);
.Ve
.Sp
will print the string \*(L"19000101T160000Z\*(R".
.IP "\(bu" 4
format_duration($duration)
.Sp
Given a \f(CW\*(C`DateTime::Duration\*(C'\fR object, this methods returns an iCal
duration string.
.Sp
The iCal standard does not allow for months or years in a duration, so
if a duration for which \f(CW\*(C`delta_months()\*(C'\fR is not zero is given, then
this method will die.
.IP "\(bu" 4
format_period($span)
.Sp
Given a \f(CW\*(C`DateTime::Span\*(C'\fR object, this methods returns an iCal
period string, using the format \f(CW\*(C`DateTime/DateTime\*(C'\fR.
.IP "\(bu" 4
format_period_with_duration($span)
.Sp
Given a \f(CW\*(C`DateTime::Span\*(C'\fR object, this methods returns an iCal
period string, using the format \f(CW\*(C`DateTime/Duration\*(C'\fR.
.IP "\(bu" 4
format_recurrence($arg [,$arg...] )
.Sp
This method returns a list of strings containing ICal statements.
In scalar context it returns a single string which may contain
embedded newlines.
.Sp
The argument can be a \f(CW\*(C`DateTime\*(C'\fR list, a \f(CW\*(C`DateTime::Span\*(C'\fR list, a
\&\f(CW\*(C`DateTime::Set\*(C'\fR, or a \f(CW\*(C`DateTime::SpanSet\*(C'\fR.
.Sp
ICal \f(CW\*(C`DATE\*(C'\fR values are not supported. Whenever a date value is found,
a \f(CW\*(C`DATE\-TIME\*(C'\fR is generated.
.Sp
If a recurrence has an associated \f(CW\*(C`DTSTART\*(C'\fR or \f(CW\*(C`DTEND\*(C'\fR, those values
must be formatted using \f(CW\*(C`format_datetime()\*(C'\fR.  The
\&\f(CW\*(C`format_recurrence()\*(C'\fR method will not do this for you.
.Sp
If a \f(CW\*(C`union\*(C'\fR or \f(CW\*(C`complement\*(C'\fR of recurrences is being formatted, they
are assumed to have the same \f(CW\*(C`DTSTART\*(C'\fR value.
.Sp
Only \f(CW\*(C`union\*(C'\fR and \f(CW\*(C`complement\*(C'\fR operations are supported for
recurrences.  This is a limitation of the ICal specification.
.Sp
If given a set it cannot format, this method may die.
.Sp
Only \f(CW\*(C`DateTime::Set::ICal\*(C'\fR objects are formattable.  A set may change
class after some set operations:
.Sp
.Vb 2
\&    $recurrence = $recurrence\->union( $dt_set );
\&    # Ok \- $recurrence still is a DT::Set::ICal
\&
\&    $recurrence = $dt_set\->union( $recurrence );
\&    # Not Ok! \- $recurrence is a DT::Set now
.Ve
.Sp
The only unbounded recurrences currently supported are the ones
generated by the \f(CW\*(C`DateTime::Event::ICal\*(C'\fR module.
.Sp
You can add ICal formatting support to a custom recurrence by using
the \f(CW\*(C`DateTime::Set::ICal\*(C'\fR module:
.Sp
.Vb 6
\&    $custom_recurrence =
\&        DateTime::Set::ICal\->from_recurrence
\&            ( recurrence =>
\&              sub { $_[0]\->truncate( to => \*(Aqmonth\*(Aq )\->add( months => 1 ) }
\&            );
\&    $custom_recurrence\->set_ical( include => [ \*(AqFREQ=MONTHLY\*(Aq ] );
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Support for this module is provided via the datetime@perl.org email
list.  See http://lists.perl.org/ for more details.
.SH "AUTHORS"
.IX Header "AUTHORS"
Dave Rolsky <autarch@urth.org> and Flavio Soibelmann Glock
<fglock@pucrs.br>
.PP
Some of the code in this module comes from Rich Bowen's \f(CW\*(C`Date::ICal\*(C'\fR
module.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 David Rolsky.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.
.PP
The full text of the license can be found in the \s-1LICENSE\s0 file included
with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
datetime@perl.org mailing list
.PP
http://datetime.perl.org/
