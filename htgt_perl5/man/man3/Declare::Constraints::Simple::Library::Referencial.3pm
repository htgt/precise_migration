.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Declare::Constraints::Simple::Library::Referencial 3"
.TH Declare::Constraints::Simple::Library::Referencial 3 "2006-09-11" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Declare::Constraints::Simple::Library::Referencial \- Ref Constraints
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # scalar or array references
\&  my $scalar_or_array = IsRefType( qw(SCALAR ARRAY) );
\&
\&  # scalar reference
\&  my $int_ref = IsScalarRef( IsInt );
\&
\&  # accept mappings of ids to objects with "name" methods
\&  my $id_obj_map = 
\&    IsHashRef( \-keys   => IsInt,
\&               \-values => And( IsObject,
\&                               HasMethods(\*(Aqname\*(Aq) ));
\&
\&  # an integer list
\&  my $int_list = IsArrayRef( IsInt );
\&
\&  # accept code references
\&  my $is_closure = IsCodeRef;
\&
\&  # accept a regular expression
\&  my $is_regex = IsRegex;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library contains those constraints that can test the validity of
references and their types.
.SH "CONSTRAINTS"
.IX Header "CONSTRAINTS"
.SS "IsRefType(@types)"
.IX Subsection "IsRefType(@types)"
Valid if the value is a reference of a kind in \f(CW@types\fR.
.SS "IsScalarRef($constraint)"
.IX Subsection "IsScalarRef($constraint)"
This is true if the value is a scalar reference. A possible constraint
for the scalar references target value can be passed. E.g.
.PP
.Vb 1
\&  my $test_integer_ref = IsScalarRef(IsInt);
.Ve
.SS "IsArrayRef($constraint)"
.IX Subsection "IsArrayRef($constraint)"
The value is valid if the value is an array reference. The contents of
the array can be validated by passing an other \f(CW$constraint\fR as 
argument.
.PP
The stack or path part of \f(CW\*(C`IsArrayRef\*(C'\fR is \f(CW\*(C`IsArrayRef[$index]\*(C'\fR where
\&\f(CW$index\fR is the index of the failing element.
.ie n .SS "IsHashRef(\-keys => $constraint, \-values => $constraint)"
.el .SS "IsHashRef(\-keys => \f(CW$constraint\fP, \-values => \f(CW$constraint\fP)"
.IX Subsection "IsHashRef(-keys => $constraint, -values => $constraint)"
True if the value is a hash reference. It can also take two named
parameters: \f(CW\*(C`\-keys\*(C'\fR can pass a constraint to check the hashes keys,
\&\f(CW\*(C`\-values\*(C'\fR does the same for its values.
.PP
The stack or path part of \f(CW\*(C`IsHashRef\*(C'\fR looks like 
\&\f(CW\*(C`IsHashRef[$type $key]\*(C'\fR where \f(CW$type\fR is either \f(CW\*(C`val\*(C'\fR or \f(CW\*(C`key\*(C'\fR 
depending on what was validated, and \f(CW$key\fR being the key that didn't 
pass validation.
.SS "\fIIsCodeRef()\fP"
.IX Subsection "IsCodeRef()"
Code references have to be valid to pass this constraint.
.SS "\fIIsRegex()\fP"
.IX Subsection "IsRegex()"
True if the value is a regular expression built with \f(CW\*(C`qr\*(C'\fR. \fBNote\fR
however, that a simple string that could be used like \f(CW\*(C`/$rx/\*(C'\fR will
not pass this constraint. You can combine multiple constraints with
And(@constraints) though.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Declare::Constraints::Simple, Declare::Constraints::Simple::Library
.SH "AUTHOR"
.IX Header "AUTHOR"
Robert 'phaylon' Sedlacek \f(CW\*(C`<phaylon@dunkelheit.at>\*(C'\fR
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This module is free software, you can redistribute it and/or modify it 
under the same terms as perl itself.
