.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::Cover::Tutorial 3"
.TH Devel::Cover::Tutorial 3 "2013-06-01" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::Cover::Tutorial \- An introduction to code coverage
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "TUTORIAL"
.IX Header "TUTORIAL"
Here's part of a message I sent to perl-qa about code coverage metrics.
.SS "1.0 Introduction"
.IX Subsection "1.0 Introduction"
It is wise to remember the following quote from Dijkstra, who said:
.PP
.Vb 1
\&  Testing never proves the absence of faults, it only shows their presence.
.Ve
.PP
In particular, code coverage is just one weapon in the software engineer's
testing arsenal.
.PP
Any discussion of code coverage metrics is hampered by the fact that
many authors use different terms to describe the same kind of coverage.
Here, I shall provide only a brief introduction to some of the most
common metrics.
.SS "2.0 Metrics"
.IX Subsection "2.0 Metrics"
.SS "2.1 Statement coverage"
.IX Subsection "2.1 Statement coverage"
This is the most basic form of code coverage.  A statement is covered if
it is executed.  Note that statement != line of code.  Multiple
statements on a single line can confuse issues \- the reporting if
nothing else.
.PP
Where there are sequences of statements without branches it is not
necessary to count the execution of every statement, just one will
suffice, but people often like the count of every line to be reported,
especially in summary statistics.  However it is not clear to me that
this is actually useful.
.PP
This type of coverage is fairly weak in that even with 100% statement
coverage there may still be serious problems in a program which could be
discovered through other types of metric.
.PP
It can be quite difficult to achieve 100% statement coverage.  There may
be sections of code designed to deal with error conditions, or rarely
occurring events such as a signal received during a certain section of
code.  There may also be code that should never be executed:
.PP
.Vb 4
\&  if ($param > 20)
\&  {
\&    die "This should never happen!";
\&  }
.Ve
.PP
It can be useful to mark such code in some way and flag an error if it
is executed.
.PP
Statement coverage, or something very similar, can be called statement
execution, line, block, basic block or segment coverage.  I tend to
favour block coverage which does not attempt to extend its results to
each statement.
.SS "2.2 Branch coverage"
.IX Subsection "2.2 Branch coverage"
The goal of branch coverage is to ensure that whenever a program can
jump, it jumps to all possible destinations.  The most simple example is
a complete if statement:
.PP
.Vb 8
\&  if ($x)
\&  {
\&    print "a";
\&  }
\&  else
\&  {
\&    print "b";
\&  }
.Ve
.PP
In such a simple example statement coverage is as powerful, but branch
coverage should also allow for the case where the else part is missing:
.PP
.Vb 4
\&  if ($x)
\&  {
\&    print "a";
\&  }
.Ve
.PP
Full coverage is only achieved here if \f(CW$x\fR is true on one occasion and
false on another.
.PP
100% branch coverage implies 100% statement coverage.
.PP
Branch coverage is also called decision or all edges coverage.
.SS "2.3 Path coverage"
.IX Subsection "2.3 Path coverage"
There are classes of errors that branch coverage cannot detect, such as:
.PP
.Vb 9
\&  $h = undef;
\&  if ($x)
\&  {
\&    $h = { a => 1 };
\&  }
\&  if ($y)
\&  {
\&    print $h\->{a};
\&  }
.Ve
.PP
100% branch coverage can be achieved by setting ($x, \f(CW$y\fR) to (1, 1) and then
to (0, 0).  But if we have (0, 1) then things go bang.
.PP
The purpose of path coverage is to ensure that all paths through the
program are taken.  In any reasonably sized program there will be an
enormous number of paths through the program and so in practice the
paths can be limited to a single subroutine, if the subroutine is not
too big, or simply to two consecutive branches.
.PP
In the above example there are four paths which correspond to the truth
table for \f(CW$x\fR and \f(CW$y\fR.  To achieve 100% path coverage they must all be
taken.  Note that missing elses count as paths.
.PP
In some cases it may be impossible to achieve 100% path coverage:
.PP
.Vb 3
\&  a if $x;
\&  b;
\&  c if $x;
.Ve
.PP
50% path coverage is the best you can get here.
.PP
Loops also contribute to paths, and pose their own problems which I'll
ignore for now.
.PP
100% path coverage implies 100% branch coverage.
.PP
Path coverage and some of its close cousins, are also known as
predicate, basis path and \s-1LCSAJ\s0 (Linear Code Sequence and Jump)
coverage.
.SS "2.4 Expression coverage"
.IX Subsection "2.4 Expression coverage"
When a boolean expression is evaluated it can be useful to ensure that
all the terms in the expression are exercised.  For example:
.PP
.Vb 1
\&  a if $x || $y
.Ve
.PP
The expression should be exercised with ($x, \f(CW$y\fR) set to (0, 0) (required
for branch coverage), (0, 1) and (1, 0) (to ensure that \f(CW$x\fR and \f(CW$y\fR are
independent) and possibly with (1, 1).
.PP
Expression coverage gets complicated, and difficult to achieve, as the
expression gets complicated.
.PP
Expressions which are not directly a part of a branching construct
should also be covered:
.PP
.Vb 2
\&  $z = $x || $y;
\&  a if $z;
.Ve
.PP
Expression coverage is also known as condition, condition-decision and
multiple decision coverage.
.SS "3.0 Other considerations"
.IX Subsection "3.0 Other considerations"
In order to get people to actually use code coverage it needs to be
simple to use.  It should also be simple to understand the results and
to rectify any problems thrown up.  Finally, if the overhead is too
great it won't get used either.
.PP
So there's a basic tutorial on code coverage, or at least my version of
it.  Typing a few of these terms into google will probably provide a
basis for future research.
.SH "LICENCE"
.IX Header "LICENCE"
Copyright 2001\-2013, Paul Johnson (paul@pjcj.net)
.PP
This software is free.  It is licensed under the same terms as Perl itself.
.PP
The latest version of this software should be available from my homepage:
http://www.pjcj.net
