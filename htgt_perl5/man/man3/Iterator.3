.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Iterator 3"
.TH Iterator 3 "2005-10-10" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Iterator \- A general\-purpose iterator class.
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.03 of Iterator.pm, October 10, 2005.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Iterator;
\&
\& # Making your own iterators from scratch:
\& $iterator = Iterator\->new ( sub { code } );
\&
\& # Accessing an iterator\*(Aqs values in turn:
\& $next_value = $iterator\->value();
\&
\& # Is the iterator out of values?
\& $boolean = $iterator\->is_exhausted();
\& $boolean = $iterator\->isnt_exhausted();
\&
\& # Within {code}, above:
\& Iterator::is_done();    # to signal end of sequence.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is meant to be the definitive implementation of iterators,
as popularized by Mark Jason Dominus's lectures and recent book
(\fIHigher Order Perl\fR, Morgan Kauffman, 2005).
.PP
An \*(L"iterator\*(R" is an object, represented as a code block that generates
the \*(L"next value\*(R" of a sequence, and generally implemented as a
closure.  When you need a value to operate on, you pull it from the
iterator.  If it depends on other iterators, it pulls values from them
when it needs to.  Iterators can be chained together (see
Iterator::Util for functions that help you do just that), queueing
up work to be done but \fInot actually doing it\fR until a value is
needed at the front end of the chain.  At that time, one data value is
pulled through the chain.
.PP
Contrast this with ordinary array processing, where you load or
compute all of the input values at once, then loop over them in
memory.  It's analogous to the difference between looping over a file
one line at a time, and reading the entire file into an array of lines
before operating on it.
.PP
Iterator.pm provides a class that simplifies creation and use of these
iterator objects.  Other \f(CW\*(C`Iterator::\*(C'\fR modules (see \*(L"\s-1SEE ALSO\*(R"\s0)
provide many general-purpose and special-purpose iterator functions.
.PP
Some iterators are infinite (that is, they generate infinite
sequences), and some are finite.  When the end of a finite sequence is
reached, the iterator code block should throw an exception of the type
\&\f(CW\*(C`Iterator::X::Am_Now_Exhausted\*(C'\fR; this is usually done via the
\&\*(L"is_done\*(R" function..  This will signal the Iterator class to mark
the object as exhausted.  The \*(L"is_exhausted\*(R" method will then return
true, and the \*(L"isnt_exhausted\*(R" method will return false.  Any
further calls to the \*(L"value\*(R" method will throw an exception of the
type \f(CW\*(C`Iterator::X::Exhausted\*(C'\fR.  See \*(L"\s-1DIAGNOSTICS\*(R"\s0.
.PP
Note that in many, many cases, you will not need to explicitly create
an iterator; there are plenty of iterator generation and manipulation
functions in the other associated modules.  You can just plug them
together like building blocks.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\& $iter = Iterator\->new( sub { code } );
.Ve
.Sp
Creates a new iterator object.  The code block that you provide will
be invoked by the \*(L"value\*(R" method.  The code block should have some
way of maintaining state, so that it knows how to return the next
value of the sequence each time it is called.
.Sp
If the code is called after it has generated the last value in its
sequence, it should throw an exception:
.Sp
.Vb 1
\&    Iterator::X::Am_Now_Exhausted\->throw ();
.Ve
.Sp
This very commonly needs to be done, so there is a convenience
function for it:
.Sp
.Vb 1
\&    Iterator::is_done ();
.Ve
.IP "value" 4
.IX Item "value"
.Vb 1
\& $next_value = $iter\->value ();
.Ve
.Sp
Returns the next value in the iterator's sequence.  If \f(CW\*(C`value\*(C'\fR is
called on an exhausted iterator, an \f(CW\*(C`Iterator::X::Exhausted\*(C'\fR
exception is thrown.
.Sp
Note that these iterators can only return scalar values.  If you need
your iterator to return a list or hash, it will have to return an
arrayref or hashref.
.IP "is_exhausted" 4
.IX Item "is_exhausted"
.Vb 1
\& $bool = $iter\->is_exhausted ();
.Ve
.Sp
Returns true if the iterator is exhausted.  In this state, any call
to the iterator's \*(L"value\*(R" method will throw an exception.
.IP "isnt_exhausted" 4
.IX Item "isnt_exhausted"
.Vb 1
\& $bool = $iter\->isnt_exhausted ();
.Ve
.Sp
Returns true if the iterator is not yet exhausted.
.SH "FUNCTION"
.IX Header "FUNCTION"
.IP "is_done" 4
.IX Item "is_done"
.Vb 1
\& Iterator::is_done();
.Ve
.Sp
You call this function after your iterator code has generated its last
value.  See \*(L"\s-1TUTORIAL\*(R"\s0.  This is simply a convenience wrapper for
.Sp
.Vb 1
\& Iterator::X::Am_Now_Exhausted\->throw();
.Ve
.SH "THINKING IN ITERATORS"
.IX Header "THINKING IN ITERATORS"
Typically, when people approach a problem that involves manipulating a
bunch of data, their first thought is to load it all into memory, into
an array, and work with it in-place.  If you're only dealing with one
element at a time, this approach usually wastes memory needlessly.
.PP
For example, one might get a list of files to operate on, and loop
over it:
.PP
.Vb 5
\&    my @files = fetch_file_list(....);
\&    foreach my $file (@files)
\&        ...
\&If C<fetch_file_list> were modified to return an iterator instead of
\&an array, the same code could look like this:
\&
\&    my $file_iterator = fetch_file_list(...)
\&    while ($file_iterator\->isnt_exhausted)
\&        ...
.Ve
.PP
The advantage here is that the whole list does not take up memory
while each individual element is being worked on.  For a list of
files, that's probably not a lot of overhead.  For the contents of
a file, on the other hand, it could be huge.
.PP
If a function requires a list of items as its input, the overhead
is tripled:
.PP
.Vb 4
\&    sub myfunc
\&    {
\&        my @things = @_;
\&        ...
.Ve
.PP
Now in addition to the array in the calling code, Perl must copy that
array to \f(CW@_\fR, and then copy it again to \f(CW@things\fR.  If you need to
massage the input from somewhere, it gets even worse:
.PP
.Vb 4
\&    my @data = get_things_from_somewhere();
\&    my @filtered_data = grep {code} @data;
\&    my @transformed_data = map {code} @filtered_data;
\&    myfunc (@transformed_data);
.Ve
.PP
If \f(CW\*(C`myfunc\*(C'\fR is rewritten to use an Iterator instead of an array,
things become much simpler:
.PP
.Vb 4
\&    my $data = ilist (get_things_from_somewhere());
\&    $filtered_data = igrep {code} $data;
\&    $transformed_data = imap {code} $filtered_data;
\&    myfunc ($transformed_data);
.Ve
.PP
(This example assumes that the \f(CW\*(C`get_things_from_somewhere\*(C'\fR function
cannot be modified to return an Iterator.  If it can, so much the
better!)  Now the original list is still in memory, inside the
\&\f(CW$data\fR Iterator, but everwhere else, there is only one data element
in memory at a time.
.PP
Another advantage of Iterators is that they're homogeneous.  This is
useful for uncoupling library code from application code.  Suppose you
have a library function that grabs data from a filehandle:
.PP
.Vb 4
\&    sub my_lib_func
\&    {
\&        my $fh = shift;
\&        ...
.Ve
.PP
If you need \f(CW\*(C`my_lib_func\*(C'\fR to get its data from a different source,
you must either modify it, or make a new copy of it that gets its
input differently, or you must jump through hoops to make the new
input stream look like a Perl filehandle.
.PP
On the other hand, if \f(CW\*(C`my_lib_func\*(C'\fR accepts an iterator, then you
can pass it data from a filehandle:
.PP
.Vb 2
\&    my $data = ifile "my_input.txt";
\&    $result = my_lib_func($data);
.Ve
.PP
Or a database handle:
.PP
.Vb 3
\&    my $data = imap {$_\->{IMPORTANT_COLUMN}}
\&               idb_rows($dbh, \*(Aqselect IMPORTANT_COLUMN from foo\*(Aq);
\&    $result = my_lib_func($data);
.Ve
.PP
If you later decide you need to transform the data, or process only
every 10th data row, or whatever:
.PP
.Vb 2
\&    $result = my_lib_func(imap {magic($_)} $data);
\&    $result = my_lib_func(inth 10, $data);
.Ve
.PP
The library function doesn't care.  All it needs is an iterator.
.PP
Chapter 4 of Dominus's book (See \*(L"\s-1SEE ALSO\*(R"\s0) covers this topic in
some detail.
.SS "Word of Warning"
.IX Subsection "Word of Warning"
When you use an iterator in separate parts of your program, or as an
argument to the various iterator functions, you do \fInot\fR get a copy
of the iterator's stream of values.
.PP
In other words, if you grab a value from an iterator, then some other
part of the program grabs a value from the same iterator, you will be
getting different values.
.PP
This can be confusing if you're not expecting it.  For example:
.PP
.Vb 4
\&    my $it_one = Iterator\->new ({something});
\&    my $it_two = some_iterator_transformation $it_one;
\&    my $value  = $it_two\->value();
\&    my $whoops = $it_one\->value;
.Ve
.PP
Here, \f(CW\*(C`some_iterator_transformation\*(C'\fR takes an iterator as an
argument, and returns an iterator as a result.  When a value is
fetched from \f(CW$it_two\fR, it internally grabs a value from \f(CW$it_one\fR
(and presumably transforms it somehow).  If you then grab a value from
\&\f(CW$it_one\fR, you'll get its \fIsecond\fR value (or third, or whatever,
depending on how many values \f(CW$it_two\fR grabbed), not the first.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
Let's create a date iterator.  It'll take a DateTime object as a
starting date, and return successive days \*(-- that is, it'll add 1 day
each iteration.  It would be used as follows:
.PP
.Vb 1
\& use DateTime;
\&
\& $iter = (...something...);
\& $day1 = $iter\->value;           # Initial date
\& $day2 = $iter\->value;           # One day later
\& $day3 = $iter\->value;           # Two days later
.Ve
.PP
The easiest way to create such an iterator is by using a \fIclosure\fR.
If you're not familiar with the concept, it's fairly simple: In Perl,
the code within an \fIanonymous block\fR has access to all the \fIlexical
variables\fR that were in scope at the time the block was created.
After the program then leaves that lexical scope, those lexical
variables remain accessible by that code block for as long as it
exists.
.PP
This makes it very easy to create iterators that maintain their own
state.  Here we'll create a lexical scope by using a pair of braces:
.PP
.Vb 10
\& my $iter;
\& {
\&    my $dt = DateTime\->now();
\&    $iter = Iterator\->new( sub
\&    {
\&        my $return_value = $dt\->clone;
\&        $dt\->add(days => 1);
\&        return $return_value;
\&    });
\&}
.Ve
.PP
Because \f(CW$dt\fR is lexically scoped to the outermost block, it is not
addressable from any code elsewhere in the program.  But the anonymous
block within the \*(L"new\*(R" method's parentheses \fIcan\fR see \f(CW$dt\fR.  So
\&\f(CW$dt\fR does not get garbage-collected as long as \f(CW$iter\fR contains a
reference to it.
.PP
The code within the anonymous block is simple.  A copy of the current
\&\f(CW$dt\fR is made, one day is added to \f(CW$dt\fR, and the copy is returned.
.PP
You'll probably want to encapsulate the above block in a subroutine,
so that you could call it from anywhere in your program:
.PP
.Vb 10
\& sub date_iterator
\& {
\&     my $dt = DateTime\->now();
\&     return Iterator\->new( sub
\&     {
\&         my $return_value = $dt\->clone;
\&         $dt\->add(days => 1);
\&         return $return_value;
\&     });
\& }
.Ve
.PP
If you look at the source code in Iterator::Util, you'll see that
just about all of the functions that create iterators look very
similar to the above \f(CW\*(C`date_iterator\*(C'\fR function.
.PP
Of course, you'd probably want to be able to pass arguments to
\&\f(CW\*(C`date_iterator\*(C'\fR, say a starting date, maybe an increment other than
\&\*(L"1 day\*(R".  But the basic idea is the same.
.PP
The above date iterator is an infinite (well, unbounded) iterator.
Let's look at how to indicate that your iterator has reached the end
of its sequence of values.  Let's write a scaled-down version of
irange from the Iterator::Util module \*(-- one
that takes a start value and an end value and always increments by 1.
.PP
.Vb 3
\& sub irange_limited
\& {
\&     my ($start, $end) = @_;
\&
\&     return Iterator\->new (sub
\&     {
\&         Iterator::is_done
\&             if $start > $end;
\&
\&         return $start++;
\&     });
\& }
.Ve
.PP
The iterator itself is very simple (this sort of thing gets to be easy
once you get the hang of it).  The new element here is the signalling
that the sequence has ended, and the iterator's work is done.
\&\*(L"is_done\*(R" is how your code indicates this to the Iterator object.
.PP
You may also want to throw an exception if the user specified bad input
parameters.  There are a couple ways you can do this.
.PP
.Vb 5
\&     ...
\&     die "Too few parameters to irange_limited"  if @_ < 2;
\&     die "Too many parameters to irange_limited" if @_ > 2;
\&     my ($start, $end) = @_;
\&     ...
.Ve
.PP
This is the simplest way; you just use \f(CW\*(C`die\*(C'\fR (or \f(CW\*(C`croak\*(C'\fR).  You may
choose to throw an Iterator parameter error, though; this will make
your function work more like one of Iterator.pm's built in functions:
.PP
.Vb 9
\&     ...
\&     Iterator::X::Parameter_Error\->throw(
\&         "Too few parameters to irange_limited")
\&         if @_ < 2;
\&     Iterator::X::Parameter_Error\->throw(
\&         "Too many parameters to irange_limited")
\&         if @_ > 2;
\&     my ($start, $end) = @_;
\&     ...
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
No symbols are exported to the caller's namespace.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Iterator uses Exception::Class objects for throwing exceptions.
If you're not familiar with Exception::Class, don't worry; these
exception objects work just like \f(CW$@\fR does with \f(CW\*(C`die\*(C'\fR and \f(CW\*(C`croak\*(C'\fR,
but they are easier to work with if you are trapping errors.
.PP
All exceptions thrown by Iterator have a base class of Iterator::X.
You can trap errors with an eval block:
.PP
.Vb 1
\& eval { $foo = $iterator\->value(); };
.Ve
.PP
and then check for errors as follows:
.PP
.Vb 1
\& if (Iterator::X\->caught())  {...
.Ve
.PP
You can look for more specific errors by looking at a more specific
class:
.PP
.Vb 1
\& if (Iterator::X::Exhausted\->caught())  {...
.Ve
.PP
Some exceptions may provide further information, which may be useful
for your exception handling:
.PP
.Vb 4
\& if (my $ex = Iterator::X::User_Code_Error\->caught())
\& {
\&     my $exception = $ex\->eval_error();
\&     ...
.Ve
.PP
If you choose not to (or cannot) handle a particular type of exception
(for example, there's not much to be done about a parameter error),
you should rethrow the error:
.PP
.Vb 11
\& if (my $ex = Iterator::X\->caught())
\& {
\&     if ($ex\->isa(\*(AqIterator::X::Something_Useful\*(Aq))
\&     {
\&         ...
\&     }
\&     else
\&     {
\&         $ex\->rethrow();
\&     }
\& }
.Ve
.IP "\(bu" 4
Parameter Errors
.Sp
Class: \f(CW\*(C`Iterator::X::Parameter_Error\*(C'\fR
.Sp
You called an Iterator method with one or more bad parameters.  Since
this is almost certainly a coding error, there is probably not much
use in handling this sort of exception.
.Sp
As a string, this exception provides a human-readable message about
what the problem was.
.IP "\(bu" 4
Exhausted Iterators
.Sp
Class: \f(CW\*(C`Iterator::X::Exhausted\*(C'\fR
.Sp
You called \*(L"value\*(R" on an iterator that is exhausted; that is, there
are no more values in the sequence to return.
.Sp
As a string, this exception is \*(L"Iterator is exhausted.\*(R"
.IP "\(bu" 4
End of Sequence
.Sp
Class: \f(CW\*(C`Iterator::X::Am_Now_Exhausted\*(C'\fR
.Sp
This exception is not thrown directly by any Iterator.pm methods, but
is to be thrown by iterator sequence generation code; that is, the
code that you pass to the \*(L"new\*(R" constructor.  Your code won't catch
an \f(CW\*(C`Am_Now_Exhausted\*(C'\fR exception, because the Iterator object will
catch it internally and set its \*(L"is_exhausted\*(R" flag.
.Sp
The simplest way to throw this exception is to use the \*(L"is_done\*(R"
function:
.Sp
.Vb 1
\& Iterator::is_done() if $something;
.Ve
.IP "\(bu" 4
User Code Exceptions
.Sp
Class: \f(CW\*(C`Iterator::X::User_Code_Error\*(C'\fR
.Sp
This exception is thrown when the sequence generation code throws any
sort of error besides \f(CW\*(C`Am_Now_Exhausted\*(C'\fR.  This could be because your
code explicitly threw an error (that is, \f(CW\*(C`die\*(C'\fRd), or because it
otherwise encountered an exception (any runtime error).
.Sp
This exception has one method, \f(CW\*(C`eval_error\*(C'\fR, which returns the
original \f(CW$@\fR that was trapped by the Iterator object.  This may be a
string or an object, depending on how \f(CW\*(C`die\*(C'\fR was invoked.
.Sp
As a string, this exception evaluates to the stringified \f(CW$@\fR.
.IP "\(bu" 4
I/O Errors
.Sp
Class: \f(CW\*(C`Iterator::X::IO_Error\*(C'\fR
.Sp
This exception is thrown when any sort of I/O error occurs; this
only happens with the filesystem iterators.
.Sp
This exception has one method, \f(CW\*(C`os_error\*(C'\fR, which returns the original
\&\f(CW$!\fR that was trapped by the Iterator object.
.Sp
As a string, this exception provides some human-readable information
along with \f(CW$!\fR.
.IP "\(bu" 4
Internal Errors
.Sp
Class: \f(CW\*(C`Iterator::X::Internal_Error\*(C'\fR
.Sp
Something happened that I thought couldn't possibly happen.  I would
appreciate it if you could send me an email message detailing the
circumstances of the error.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Requires the following additional module:
.PP
Exception::Class, v1.21 or later.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\fIHigher Order Perl\fR, Mark Jason Dominus, Morgan Kauffman 2005.
.Sp
<http://perl.plover.com/hop/>
.IP "\(bu" 4
The Iterator::Util module, for general-purpose iterator functions.
.IP "\(bu" 4
The Iterator::IO module, for filesystem and stream iterators.
.IP "\(bu" 4
The Iterator::DBI module, for iterating over a \s-1DBI\s0 record set.
.IP "\(bu" 4
The Iterator::Misc module, for various oddball iterator functions.
.SH "THANKS"
.IX Header "THANKS"
Much thanks to Will Coleda and Paul Lalli (and the \s-1RPI\s0 lily crowd in
general) for suggestions for the pre-release version.
.SH "AUTHOR / COPYRIGHT"
.IX Header "AUTHOR / COPYRIGHT"
Eric J. Roode, roode@cpan.org
.PP
Copyright (c) 2005 by Eric J. Roode.  All Rights Reserved.
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
To avoid my spam filter, please include \*(L"Perl\*(R", \*(L"module\*(R", or this
module's name in the message's subject line, and/or GPG-sign your
message.
