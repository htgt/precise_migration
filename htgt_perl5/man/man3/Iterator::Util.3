.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2005-08-23" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Iterator::Util \- Essential utilities for the Iterator class.
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.02 of Iterator::Util, August 23, 2005.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Iterator::Util;
\&
\& # Transform sequences
\& $iterator = imap { transformation code } $some_other_iterator;
\&
\& # Filter sequences
\& $iterator = igrep { condition code } $some_other_iterator;
\&
\& # Range of values  (arithmetic sequence)
\& $iter = irange ($start, $end, $increment);
\& $iter = irange ($start, $end);
\& $iter = irange ($start);
\&
\& # Iterate over an arbitrary list
\& $iter = ilist (item, item, ...);
\& $iter = ilist (@items);
\&
\& # Iterate over an array, by reference
\& $iter = iarray (\e@array);
\&
\& # Return at most $num items from an iterator
\& $iter   = ihead ($num, $some_other_iterator);
\& @values = ihead ($num, $some_other_iterator);
\&
\& # Append multiple iterators into one
\& $iter = iappend ($it1, $it2, $it3, ...);
\&
\& # Apply a function to pairs of iterator values
\& $iter = ipairwise {code} $iter_A, $iter_B;
\&
\& # Skip the first $num values of an iterator
\& $iter = iskip ($num, $some_other_iterator);
\&
\& # Skip values from an iterator until a condition is met
\& $iter = iskip_until {code} $some_other_iterator;
\&
\& # Mesh iterators together
\& $iter = imesh ($iter, $iter, ...);
\& $iter = izip  ($iter, $iter, ...);
\&
\& # Return each value of an iterator once
\& $iter = iuniq ($another_iterator);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements many useful functions for creating and
manipulating iterator objects.
.PP
An \*(L"iterator\*(R" is an object, represented as a code block that generates
the \*(L"next value\*(R" of a sequence, and generally implemented as a
closure.  For further information, including a tutorial on using
iterator objects, see the Iterator documentation.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "imap" 4
.IX Item "imap"
.Vb 1
\& $iter = imap { transformation code } $some_other_iterator;
.Ve
.Sp
Returns an iterator that is a transformation of some other iterator.
Within the transformation code, \f(CW$_\fR is set to each value of the
other iterator, in turn.
.Sp
\&\fIExamples:\fR
.Sp
.Vb 2
\& $evens   = imap { $_ * 2  }  irange (0);  # returns 0, 2, 4, ...
\& $squares = imap { $_ * $_ }  irange (7);  # 49, 64, 81, 100, ...
.Ve
.IP "igrep" 4
.IX Item "igrep"
.Vb 1
\& $iter = igrep { condition } $some_other_iterator;
.Ve
.Sp
Returns an iterator that selectively returns values from some other
iterator.  Within the \f(CW\*(C`condition\*(C'\fR code, \f(CW$_\fR is set to each value of
the other iterator, in turn.
.Sp
\&\fIExamples:\fR
.Sp
.Vb 2
\& $fives = igrep { $_ % 5 == 0 } irange (0,10);   # returns 0, 5, 10
\& $small = igrep { $_ < 10 }     irange (8,12);   # returns 8, 9
.Ve
.IP "irange" 4
.IX Item "irange"
.Vb 3
\& $iter = irange ($start, $end, $increment);
\& $iter = irange ($start, $end);
\& $iter = irange ($start);
.Ve
.Sp
\&\f(CW\*(C`irange\*(C'\fR returns a sequence of numbers.  The sequence begins with
\&\f(CW$start\fR, ends at \f(CW$end\fR, and steps by \f(CW$increment\fR.  This is sort
of the Iterator version of a \f(CW\*(C`for\*(C'\fR loop.
.Sp
If \f(CW$increment\fR is not specified, 1 is used.  \f(CW$increment\fR may be
negative \*(-- or even zero, in which case iterator returns an infinite
sequence of \f(CW$start\fR.
.Sp
If \f(CW$end\fR is not specified (is \f(CW\*(C`undef\*(C'\fR), the sequence is infinite.
.Sp
\&\fIExamples:\fR
.Sp
.Vb 4
\& $iter = irange (1, 2);           #  Iterate from 1 to 2
\& $val  = $iter\->value();          #  $val is now 1.
\& $val  = $iter\->value();          #  $val is now 2.
\& $bool = $iter\->is_exhausted();   #  $bool is now true.
\&
\& $iter = irange (10, 8, \-1);      #  Iterate from 10 down to 8
\& $iter = irange (1);              #  Iterate from 1, endlessly.
.Ve
.IP "ilist" 4
.IX Item "ilist"
.Vb 1
\& $iter = ilist (@items);
.Ve
.Sp
Returns an iterator that iterates over an arbitrary sequence of
values.  It's sort of an Iterator version of \f(CW\*(C`foreach\*(C'\fR.
.Sp
This function makes an internal copy of the list, so it may not be
appropriate for an extremely large list.
.Sp
\&\fIExample:\fR
.Sp
.Vb 4
\& $iter = ilist (4, \*(Aqminus five\*(Aq, @foo, 7);
\& $val  = $iter\->value();          # $val is now 4
\& $val  = $iter\->value();          # $val is now \*(Aqminus five\*(Aq
\& ...
.Ve
.IP "iarray" 4
.IX Item "iarray"
.Vb 1
\& $iter = iarray (\e@array);
.Ve
.Sp
Returns an iterator that iterates over an array.  Note that since it
uses a reference to that array, if you modify the array, that will be
reflected in the values returned by the iterator.  This may be What
You Want.  Or it may cause Hard-To-Find Bugs.
.IP "ihead" 4
.IX Item "ihead"
.Vb 2
\& $iter   = ihead ($num, $some_other_iterator);
\& @values = ihead ($num, $some_iterator);
.Ve
.Sp
In scalar context, creates an iterator that returns at most \f(CW$num\fR
items from another iterator, then stops.
.Sp
In list context, returns the first \f(CW$num\fR items from the iterator.
If \f(CW$num\fR is \f(CW\*(C`undef\*(C'\fR, all remaining values are pulled
from the iterator until it is exhausted.  Use \f(CW\*(C`undef\*(C'\fR with caution;
iterators can be huge \*(-- or infinite.
.Sp
\&\fIExamples:\fR
.Sp
.Vb 1
\& $iota5 = ihead 5, irange 1;    # returns 1, 2, 3, 4, 5.
\&
\& $iter = irange 1;            # infinite sequence, starting with 1
\& @vals = ihead (5, $iter);    # @vals is (1, 2, 3, 4, 5)
\& $nextval = $iter\->value;     # $nextval is 6.
.Ve
.IP "iappend" 4
.IX Item "iappend"
.Vb 1
\& $iter = iappend (@list_of_iterators);
.Ve
.Sp
Creates an iterator that consists of any number of other iterators
glued together.  The resulting iterator pulls values from the first
iterator until it's exhausted, then from the second, and so on.
.IP "ipairwise" 4
.IX Item "ipairwise"
.Vb 1
\& $iter = ipairwise {code} $it_A, $it_B;
.Ve
.Sp
Creates a new iterator which applies \f(CW\*(C`{code}\*(C'\fR to pairs of elements of
two other iterators, \f(CW$it_A\fR and \f(CW$it_B\fR in turn.  The pairs are
assigned to \f(CW$a\fR and \f(CW$b\fR before invoking the code.
.Sp
The new iterator is exhausted when either \f(CW$it_A\fR or \f(CW$it_B\fR are
exhausted.
.Sp
This function is analogous to the pairwise
function from List::MoreUtils.
.Sp
\&\fIExample:\fR
.Sp
.Vb 3
\& $first  = irange 1;                              # 1,  2,  3,  4, ...
\& $second = irange 4, undef, 2;                    # 4,  6,  8, 10, ...
\& $third  = ipairwise {$a * $b} $first, $second;   # 4, 12, 24, 40, ...
.Ve
.IP "iskip" 4
.IX Item "iskip"
.Vb 1
\& $iter = iskip ($num, $another_iterator);
.Ve
.Sp
Returns an iterator that contains the values of \f(CW$another_iterator\fR,
minus the first \f(CW$num\fR values.  In other words, skips the first
\&\f(CW$num\fR values of \f(CW$another_iterator\fR.
.Sp
\&\fIExample:\fR
.Sp
.Vb 3
\& $iter = ilist (24, \-1, 7, 8);        # Bunch of random values
\& $cdr  = iskip 1, $iter;              # "pop" the first value
\& $val  = $cdr\->value();               # $val is \-1.
.Ve
.IP "iskip_until" 4
.IX Item "iskip_until"
.Vb 1
\& $iter = iskip_until {code} $another_iterator;
.Ve
.Sp
Returns an iterator that skips the leading values of \f(CW$another_iterator\fR
until \f(CW\*(C`{code}\*(C'\fR evaluates to true for one of its values.  \f(CW\*(C`{code}\*(C'\fR
can refer to the current value as \f(CW$_\fR.
.Sp
\&\fIExample:\fR
.Sp
.Vb 1
\& $iter = iskip_until {$_ > 5}  irange 1;    # returns 6, 7, 8, 9, ...
.Ve
.IP "imesh" 4
.IX Item "imesh"
.PD 0
.IP "izip" 4
.IX Item "izip"
.PD
.Vb 1
\& $iter = imesh ($iter1, $iter2, ...);
.Ve
.Sp
This iterator accepts any number of other iterators, and \*(L"meshes\*(R"
their values together.  First it returns the first value of the first
iterator, then the first value of the second iterator, and so on,
until it has returned the first value of all of its iterator
arguments.  Then it goes back and returns the second value of the
first iterator, and so on.  It stops when any of its iterator
arguments is exhausted.
.Sp
\&\fIExample:\fR
.Sp
.Vb 5
\& $i1 = ilist (\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq);
\& $i2 = ilist (1, 2, 3);
\& $i3 = ilist (\*(Aqrock\*(Aq, \*(Aqpaper\*(Aq, \*(Aqscissors\*(Aq);
\& $iter = imesh ($i1, $i2, $i3);
\& # $iter will return, in turn, \*(Aqa\*(Aq, 1, \*(Aqrock\*(Aq, \*(Aqb\*(Aq, 2, \*(Aqpaper\*(Aq, \*(Aqc\*(Aq,...
.Ve
.Sp
\&\f(CW\*(C`izip\*(C'\fR is a synonym for \f(CW\*(C`imesh\*(C'\fR.
.IP "iuniq" 4
.IX Item "iuniq"
.Vb 1
\& $iter = iuniq ($another_iterator);
.Ve
.Sp
Creates an iterator to return unique values from another iterator;
weeds out duplicates.
.Sp
\&\fIExample:\fR
.Sp
.Vb 2
\& $iter = ilist (1, 2, 2, 3, 1, 4);
\& $uniq = iuniq ($iter);            # returns 1, 2, 3, 4.
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
All function names are exported to the caller's namespace by default.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Iterator::Util uses Exception::Class objects for throwing
exceptions.  If you're not familiar with Exception::Class, don't
worry; these exception objects work just like \f(CW$@\fR does with \f(CW\*(C`die\*(C'\fR
and \f(CW\*(C`croak\*(C'\fR, but they are easier to work with if you are trapping
errors.
.PP
See the Iterator module documentation for more
information on trapping and handling these exceptions.
.IP "\(bu" 4
Parameter Errors
.Sp
Class: \f(CW\*(C`Iterator::X::Parameter_Error\*(C'\fR
.Sp
You called an Iterator method with one or more bad parameters.  Since
this is almost certainly a coding error, there is probably not much
use in handling this sort of exception.
.Sp
As a string, this exception provides a human-readable message about
what the problem was.
.IP "\(bu" 4
Exhausted Iterators
.Sp
Class: \f(CW\*(C`Iterator::X::Exhausted\*(C'\fR
.Sp
You called \f(CW\*(C`value|Iterator/value\*(C'\fR on an iterator that is exhausted;
that is, there are no more values in the sequence to return.
.Sp
As a string, this exception is \*(L"Iterator is exhausted.\*(R"
.IP "\(bu" 4
User Code Exceptions
.Sp
Class: \f(CW\*(C`Iterator::X::User_Code_Error\*(C'\fR
.Sp
This exception is thrown when the sequence generation code throws any
sort of error besides \f(CW\*(C`Am_Now_Exhausted\*(C'\fR.  This could be because your
code explicitly threw an error (that is, \f(CW\*(C`die\*(C'\fRd), or because it
otherwise encountered an exception (any runtime error).
.Sp
This exception has one method, \f(CW\*(C`eval_error\*(C'\fR, which returns the
original \f(CW$@\fR that was trapped by the Iterator object.  This may be a
string or an object, depending on how \f(CW\*(C`die\*(C'\fR was invoked.
.Sp
As a string, this exception evaluates to the stringified \f(CW$@\fR.
.IP "\(bu" 4
I/O Errors
.Sp
Class: \f(CW\*(C`Iterator::X::IO_Error\*(C'\fR
.Sp
This exception is thrown when any sort of I/O error occurs; this
only happens with the filesystem iterators.
.Sp
This exception has one method, \f(CW\*(C`os_error\*(C'\fR, which returns the original
\&\f(CW$!\fR that was trapped by the Iterator object.
.Sp
As a string, this exception provides some human-readable information
along with \f(CW$!\fR.
.IP "\(bu" 4
Internal Errors
.Sp
Class: \f(CW\*(C`Iterator::X::Internal_Error\*(C'\fR
.Sp
Something happened that I thought couldn't possibly happen.  I would
appreciate it if you could send me an email message detailing the
circumstances of the error.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Requires the following additional modules:
.PP
Iterator
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIHigher Order Perl\fR, Mark Jason Dominus, Morgan Kauffman 2005.
.PP
<http://perl.plover.com/hop/>
.SH "THANKS"
.IX Header "THANKS"
Much thanks to Will Coleda and Paul Lalli (and the \s-1RPI\s0 lily crowd in
general) for suggestions for the pre-release version.
.SH "AUTHOR / COPYRIGHT"
.IX Header "AUTHOR / COPYRIGHT"
Eric J. Roode, roode@cpan.org
.PP
Copyright (c) 2005 by Eric J. Roode.  All Rights Reserved.
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
To avoid my spam filter, please include \*(L"Perl\*(R", \*(L"module\*(R", or this
module's name in the message's subject line, and/or GPG-sign your
message.
