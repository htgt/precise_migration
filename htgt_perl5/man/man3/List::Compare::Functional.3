.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "List::Compare::Functional 3"
.TH List::Compare::Functional 3 "2008-06-08" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
List::Compare::Functional \- Compare elements of two or more lists
.SH "VERSION"
.IX Header "VERSION"
This document refers to version 0.37 of List::Compare::Functional.  
This version was released June 07, 2008.  The first released 
version of List::Compare::Functional was v0.21.  Its version numbers 
are set to be consistent with the other parts of the List::Compare 
distribution.
.SS "Notice of Interface Changes"
.IX Subsection "Notice of Interface Changes"
Certain significant changes to the interface to List::Compare::Functional 
were made with the introduction of Version 0.25 in April 2004.  The 
documentation immediately below reflects those changes, so if you are 
first using this module with that or a later version, simply read and 
follow the documentation below.  If, however, you used List::Compare::Functional 
prior to that version, see the discussion of interface changes farther 
below: April 2004 Change of Interface.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Getting Started"
.IX Subsection "Getting Started"
List::Compare::Functional exports no subroutines by default.
.PP
.Vb 1
\&    use List::Compare::Functional qw(:originals :aliases);
.Ve
.PP
will import all publicly available subroutines from 
List::Compare::Functional.  The model for importing just one subroutine from 
List::Compare::Functional is:
.PP
.Vb 1
\&    use List::Compare::Functional qw( get_intersection );
.Ve
.PP
It will probably be most convenient for the user to import functions by 
using one of the two following export tags:
.PP
.Vb 1
\&    use List::Compare::Functional qw(:main :mainrefs);
.Ve
.PP
The assignment of the various comparison functions to export tags is 
discussed below.
.PP
For clarity, we shall begin by discussing comparisons of just two lists at 
a time.  Farther below, we shall discuss comparisons among three or more 
lists at a time.
.SS "Comparing Two Lists Held in Arrays"
.IX Subsection "Comparing Two Lists Held in Arrays"
.IP "\(bu" 4
Given two lists:
.Sp
.Vb 2
\&    @Llist = qw(abel abel baker camera delta edward fargo golfer);
\&    @Rlist = qw(baker camera delta delta edward fargo golfer hilton);
.Ve
.IP "\(bu" 4
Get those items which appear at least once in both lists (their intersection).
.Sp
.Vb 1
\&    @intersection = get_intersection( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
Note that you could place the references to the lists being compared into 
a named array and then pass \f(CW\*(C`get_intersection()\*(C'\fR a reference to that array.
.Sp
.Vb 2
\&    @to_be_compared = ( \e@Llist, \e@Rlist );
\&    @intersection = get_intersection( \e@to_be_compared );
.Ve
.Sp
Beginning with version 0.29 (May 2004), List::Compare::Functional now offers 
an additional way of passing arguments to its various functions.  If you 
prefer to see a more explicit delineation among the types of arguments passed 
to a function, pass a single hash reference which holds the lists being 
compared in an anonymous array which is the value corresponding to key \f(CW\*(C`lists\*(C'\fR:
.Sp
.Vb 3
\&    @intersection = get_intersection( {
\&       lists => [ \e@Llist, \e@Rlist ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which appear at least once in either list (their union).
.Sp
.Vb 1
\&    @union = get_union( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @union = get_union( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Get those items which appear (at least once) only in the first list.
.Sp
.Vb 1
\&    @Lonly = get_unique( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @Lonly = get_unique( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Get those items which appear (at least once) only in the second list.
.Sp
.Vb 1
\&    @Ronly = get_complement( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @Ronly = get_complement( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4

.Sp
.Vb 1
\&    @LorRonly = get_symmetric_difference( [ \e@Llist, \e@Rlist ] );
\&
\&    @LorRonly = get_symdiff( [ \e@Llist, \e@Rlist ] );       # alias
.Ve
.Sp
or
.Sp
.Vb 1
\&    @LorRonly = get_symmetric_difference( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Make a bag of all those items in both lists.  The bag differs from the 
union of the two lists in that it holds as many copies of individual 
elements as appear in the original lists.
.Sp
.Vb 1
\&    @bag = get_bag( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    @bag = get_bag( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
An alternative approach to the above functions:  If you do not immediately 
require an array as the return value of the function call, but simply need 
a \fIreference\fR to an (anonymous) array, use one of the following 
parallel functions:
.Sp
.Vb 8
\&    $intersection_ref = get_intersection_ref(         [ \e@Llist, \e@Rlist ] );
\&    $union_ref        = get_union_ref(                [ \e@Llist, \e@Rlist ] );
\&    $Lonly_ref        = get_unique_ref(               [ \e@Llist, \e@Rlist ] );
\&    $Ronly_ref        = get_complement_ref(           [ \e@Llist, \e@Rlist ] );
\&    $LorRonly_ref     = get_symmetric_difference_ref( [ \e@Llist, \e@Rlist ] );
\&    $LorRonly_ref     = get_symdiff_ref(              [ \e@Llist, \e@Rlist ] );
\&                            # alias
\&    $bag_ref          = get_bag_ref(                  [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 10
\&    $intersection_ref = 
\&        get_intersection_ref(         { lists => [ \e@Llist, \e@Rlist ] } );
\&    $union_ref        = 
\&        get_union_ref(                { lists => [ \e@Llist, \e@Rlist ] } );
\&    $Lonly_ref        = 
\&        get_unique_ref(               { lists => [ \e@Llist, \e@Rlist ] } );
\&    $Ronly_ref        = 
\&        get_complement_ref(           { lists => [ \e@Llist, \e@Rlist ] } );
\&    $LorRonly_ref     = 
\&        get_symmetric_difference_ref( { lists => [ \e@Llist, \e@Rlist ] } );
\&    $LorRonly_ref     = 
\&        get_symdiff_ref(              { lists => [ \e@Llist, \e@Rlist ] } );
\&        # alias
\&    $bag_ref          = 
\&        get_bag_ref(                  { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if the first list ('L' for 'left') is a subset of the 
second list ('R' for 'right').
.Sp
.Vb 1
\&    $LR = is_LsubsetR( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $LR = is_LsubsetR( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if R is a subset of L.
.Sp
.Vb 1
\&    $RL = is_RsubsetL( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $RL = is_RsubsetL( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if L and R are equivalent, \fIi.e.,\fR if every element 
in L appears at least once in R and \fIvice versa\fR.
.Sp
.Vb 2
\&    $eqv = is_LequivalentR( [ \e@Llist, \e@Rlist ] );
\&    $eqv = is_LeqvlntR( [ \e@Llist, \e@Rlist ] );            # alias
.Ve
.Sp
or
.Sp
.Vb 1
\&    $eqv = is_LequivalentR( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Return a true value if L and R are disjoint, \fIi.e.,\fR if L and R have 
no common elements.
.Sp
.Vb 1
\&    $disj = is_LdisjointR( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $disj = is_LdisjointR( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing whether one list is a subset of the other.
.Sp
.Vb 1
\&    print_subset_chart( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_subset_chart( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing whether the two lists are equivalent (same 
elements found at least once in both).
.Sp
.Vb 1
\&    print_equivalence_chart( [ \e@Llist, \e@Rlist ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_equivalence_chart( { lists => [ \e@Llist, \e@Rlist ] } );
.Ve
.IP "\(bu" 4
Determine in \fIwhich\fR (if any) of the lists a given string can be found.  
In list context, return a list of those indices in the argument list 
corresponding to lists holding the string being tested.
.Sp
.Vb 1
\&    @memb_arr = is_member_which( [ \e@Llist, \e@Rlist ] , [ \*(Aqabel\*(Aq ] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @memb_arr = is_member_which( {
\&        lists => [ \e@Llist, \e@Rlist ],  # value is array reference
\&        item  => \*(Aqabel\*(Aq,                # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW@memb_arr\fR will be:
.Sp
.Vb 1
\&    ( 0 )
.Ve
.Sp
because \f(CW\*(Aqabel\*(Aq\fR is found only in \f(CW@Al\fR which holds position \f(CW0\fR in the 
list of arguments passed to \f(CW\*(C`new()\*(C'\fR.
.IP "\(bu" 4
As with other List::Compare::Functional functions which return a list, you 
may wish the above function returned a (scalar) reference to an array 
holding the list:
.Sp
.Vb 1
\&    $memb_arr_ref = is_member_which_ref( [ \e@Llist, \e@Rlist ] , [ \*(Aqbaker\*(Aq ] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_arr_ref = is_member_which_ref( {
\&        lists => [ \e@Llist, \e@Rlist ],  # value is array reference
\&        item  => \*(Aqbaker\*(Aq,               # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW$memb_arr_ref\fR will be:
.Sp
.Vb 1
\&    [ 0, 1 ]
.Ve
.Sp
because \f(CW\*(Aqbaker\*(Aq\fR is found in \f(CW@Llist\fR and \f(CW@Rlist\fR, which hold positions 
\&\f(CW0\fR and \f(CW1\fR, respectively, in the list of arguments passed to \f(CW\*(C`new()\*(C'\fR.
.Sp
\&\fBNote:\fR  functions \f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref\*(C'\fR test
only one string at a time and hence take only one argument.  To test more 
than one string at a time see the next function, \f(CW\*(C`are_members_which()\*(C'\fR.
.IP "\(bu" 4
Determine in \f(CW\*(C`which\*(C'\fR (if any) of the lists passed as arguments one or 
more given strings can be found.  The lists beings searched are placed in an 
array, a reference to which is the first argument passed to 
\&\f(CW\*(C`are_members_which()\*(C'\fR.  The strings to be tested are also placed in an 
array, a reference to which is the second argument passed to that function.
.Sp
.Vb 4
\&    $memb_hash_ref = 
\&        are_members_which( [ \e@Llist, \e@Rlist ] , 
\&                           [ qw| abel baker fargo hilton zebra | ]
\&                         );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_which( {
\&        lists => [ \e@Llist, \e@Rlist ],                    # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return value is a reference to a hash of arrays.  The 
key for each element in this hash is the string being tested.  Each element's 
value is a reference to an anonymous array whose elements are those indices in 
the constructor's argument list corresponding to lists holding the strings 
being tested.  In the examples above, \f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => [ 0    ],
\&         baker    => [ 0, 1 ],
\&         fargo    => [ 0, 1 ],
\&         hilton   => [    1 ],
\&         zebra    => [      ],
\&    };
.Ve
.Sp
\&\fBNote:\fR  \f(CW\*(C`are_members_which()\*(C'\fR can take more than one argument; 
\&\f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref()\*(C'\fR each take only one argument.  
Unlike those functions, \f(CW\*(C`are_members_which()\*(C'\fR returns a hash reference.
.IP "\(bu" 4
Determine whether a given string can be found in \fIany\fR of the lists passed as 
arguments.  Return \f(CW1\fR if a specified string can be found in any of the lists 
and \f(CW0\fR if not.
.Sp
.Vb 1
\&    $found = is_member_any( [ \e@Llist, \e@Rlist ] , [ \*(Aqabel\*(Aq ] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $found = is_member_any( {
\&        lists => [ \e@Llist, \e@Rlist ], # value is array reference
\&        item  => \*(Aqabel\*(Aq,               # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW$found\fR will be \f(CW1\fR because \f(CW\*(Aqabel\*(Aq\fR is found in one 
or more of the lists passed as arguments to \f(CW\*(C`new()\*(C'\fR.
.IP "\(bu" 4
Determine whether a specified string or strings can be found in \fIany\fR of the 
lists passed as arguments. The lists beings searched are placed in an  
array, a reference to which is the first argument passed to 
\&\f(CW\*(C`are_members_any()\*(C'\fR.  The strings to be tested are also placed in an 
array, a reference to which is the second argument passed to that function.
.Sp
.Vb 4
\&    $memb_hash_ref = 
\&        are_members_any( [ \e@Llist, \e@Rlist ] , 
\&                         [ qw| abel baker fargo hilton zebra | ]
\&                       );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_any( {
\&        lists => [ \e@Llist, \e@Rlist ],                    # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return value is a reference to a hash where an element's key is the 
string being tested and the element's value is \f(CW1\fR if the string can be 
found in \fIany\fR of the lists and \f(CW0\fR if not.  In the examples above, 
\&\f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => 1,
\&         baker    => 1,
\&         fargo    => 1,
\&         hilton   => 1,
\&         zebra    => 0,
\&    };
.Ve
.Sp
\&\f(CW\*(C`zebra\*(C'\fR's value is \f(CW0\fR because \f(CW\*(C`zebra\*(C'\fR is not found in either of the lists 
passed as arguments to \f(CW\*(C`are_members_any()\*(C'\fR.
.IP "\(bu" 4
Return current List::Compare::Functional version number.
.Sp
.Vb 1
\&    $vers = get_version;
.Ve
.SS "Comparing Three or More Lists Held in Arrays"
.IX Subsection "Comparing Three or More Lists Held in Arrays"
Given five lists:
.PP
.Vb 5
\&    @Al     = qw(abel abel baker camera delta edward fargo golfer);
\&    @Bob    = qw(baker camera delta delta edward fargo golfer hilton);
\&    @Carmen = qw(fargo golfer hilton icon icon jerky kappa);
\&    @Don    = qw(fargo icon jerky);
\&    @Ed     = qw(fargo icon icon jerky);
.Ve
.IP "\(bu" 4
Get those items which appear at least once in \fIeach\fR list (their intersection).
.Sp
.Vb 1
\&    @intersection = get_intersection( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @intersection = get_intersection( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which appear at least once in \fIany\fR of the lists (their union).
.Sp
.Vb 1
\&    @union = get_union( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
    \f(CW@union\fR = get_union( {
        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
    } );
.IP "\(bu" 4
To get those items which are unique to a particular list, provide \f(CW\*(C`get_unique()\*(C'\fR 
with two array references.  The first holds references to the arrays 
which in turn hold the individual lists being compared.  The second holds 
the index position in the first reference of the particular list under 
consideration.  Example:  To get elements unique to \f(CW@Carmen\fR:
.Sp
.Vb 4
\&    @Lonly = get_unique(
\&                 [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], 
\&                 [ 2 ]
\&             );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @Lonly = get_unique( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => 2,                                      # value is number
\&    } );
.Ve
.Sp
If no index position is passed to \f(CW\*(C`get_unique()\*(C'\fR it will default to \f(CW0\fR 
and report items unique to the first list passed to the function.  Hence,
.Sp
.Vb 1
\&    @Lonly = get_unique( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
is same as:
.Sp
.Vb 1
\&    @Lonly = get_unique( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [ 0 ] );
.Ve
.IP "\(bu" 4
Should you need to identify the items unique to \fIeach\fR of the lists under 
consideration, call \f(CW\*(C`get_unique_all\*(C'\fR and get a reference to an array of 
array references:
.Sp
.Vb 3
\&    $unique_all_ref = get_unique_all(
\&        [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ]
\&    );
.Ve
.Sp
or
.Sp
.Vb 3
\&    $unique_all_ref = get_unique_all( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
To get those items which appear only in lists \fIother than\fR one particular 
list, pass two array references to the \f(CW\*(C`get_complement()\*(C'\fR  function.  
The first holds references to the arrays which in turn hold the individual lists 
being compared.  The second holds the index position in the first reference 
of the particular list under consideration.  Example:  to get all the 
elements found in lists other than \f(CW@Don\fR:
.Sp
.Vb 4
\&    @Ronly = get_complement(
\&                 [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                 [ 3 ]
\&             );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @Ronly = get_complement( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => 3,                                      # value is number
\&    } );
.Ve
.Sp
If no index position is passed to \f(CW\*(C`get_complement()\*(C'\fR it will default to \f(CW0\fR 
and report items found in all lists \fIother than\fR the first list passed to 
\&\f(CW\*(C`get_complement()\*(C'\fR.
.Sp
.Vb 1
\&    @Lonly = get_complement( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
is same as:
.Sp
.Vb 1
\&    @Lonly = get_complement( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [ 0 ] );
.Ve
.IP "\(bu" 4
Should you need to identify the items not found in \fIeach\fR of the lists under 
consideration, call \f(CW\*(C`get_complement_all\*(C'\fR and get a reference to an array of 
array references:
.Sp
.Vb 3
\&    $complement_all_ref = get_complement_all(
\&        [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ]
\&    );
.Ve
.Sp
or
.Sp
.Vb 3
\&    $complement_all_ref = get_complement_all( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which do \fInot\fR appear in \fImore than one\fR of several lists 
(their symmetric_difference);
.Sp
.Vb 2
\&    @LorRonly = get_symmetric_difference( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    @LorRonly = get_symdiff( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] ); # alias
.Ve
.Sp
or
.Sp
.Vb 3
\&    @LorRonly = get_symmetric_difference( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items found in \fIany\fR of several lists which do \fInot\fR appear 
in \f(CW\*(C`all\*(C'\fR of the lists (\fIi.e.,\fR all items except those found in the 
intersection of the lists):
.Sp
.Vb 2
\&    @nonintersection = get_nonintersection(
\&                           [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @nonintersection = get_nonintersection( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Get those items which appear in \fImore than one\fR of several lists 
(\fIi.e.,\fR all items except those found in their symmetric difference);
.Sp
.Vb 1
\&    @shared = get_shared( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @shared = get_shared( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
Make a bag of every item found in every list.  The bag differs from the 
union of the two lists in that it holds as many copies of individual 
elements as appear in the original lists.
.Sp
.Vb 1
\&    @bag = get_bag( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 3
\&    @bag = get_bag( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&    } );
.Ve
.IP "\(bu" 4
An alternative approach to the above functions:  If you do not immediately 
require an array as the return value of the function, but simply need 
a \fIreference\fR to an array, use one of the following parallel functions:
.Sp
.Vb 10
\&    $intersection_ref    = get_intersection_ref( 
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $union_ref           = get_union_ref( 
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $Lonly_ref           = get_unique_ref( 
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $Ronly_ref           = get_complement_ref( 
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $LorRonly_ref        = get_symmetric_difference_ref( 
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $LorRonly_ref        = get_symdiff_ref(            # alias
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $nonintersection_ref = get_nonintersection_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $shared_ref          = get_shared_ref(
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
\&    $bag_ref             = get_bag_ref( 
\&                             [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.IP "\(bu" 4
To determine whether one particular list is a subset of another of the 
lists passed to the function, pass to \f(CW\*(C`is_LsubsetR()\*(C'\fR two array references. 
The first of these is a reference to an array of array 
references, the arrays holding the lists under consideration.  The 
second is a reference to a two-element array consisting of the 
index of the presumed subset, followed by the index position of the presumed 
superset.  A true value (\f(CW1\fR) is returned if the first (left-hand) element 
in the second reference list is a subset of the second (right-hand) element; 
a false value (\f(CW0\fR) is returned otherwise.
.Sp
Example:  To determine whether \f(CW@Ed\fR is a subset of \f(CW@Carmen\fR, call:
.Sp
.Vb 4
\&    $LR = is_LsubsetR(
\&              [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], 
\&              [ 4, 2 ]
\&          );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $LR = is_LsubsetR( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        pair  => [ 4, 2 ],                               # value is arrayref
\&    } );
.Ve
.Sp
If only the first reference (to the array of lists) is passed to 
\&\f(CW\*(C`is_LsubsetR\*(C'\fR, then the function's second argument defaults to \f(CW\*(C`(0,1)\*(C'\fR and 
compares the first two lists passed to the constructor.  So,
.Sp
.Vb 1
\&    $LR = is_LsubsetR([ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
\&... is equivalent to:
.Sp
.Vb 1
\&    $LR = is_LsubsetR([ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [0,1] );
.Ve
.IP "\(bu" 4
To reverse the order in which the particular lists are evaluated for 
superset/subset status, call \f(CW\*(C`is_RsubsetL\*(C'\fR:
.Sp
.Vb 1
\&    $RL = is_RsubsetL([ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [2,4] );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $RL = is_RsubsetL( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&        pair  => [ 2, 4 ],
\&    } );
.Ve
.IP "\(bu" 4
List::Compare::Functional considers two lists to be equivalent if 
every element in one list appears at least once in R and \fIvice versa\fR.  
To determine whether one particular list passed to the function is 
equivalent to another of the lists passed to the function, provide 
\&\f(CW\*(C`is_LequivalentR()\*(C'\fR with two array references. 
The first is a reference to an array of array 
references, the arrays holding the lists under consideration.  The 
second of these is a reference to a two-element array consisting of the 
two lists being tested for equivalence.  A true value (\f(CW1\fR) is returned if 
the lists are equivalent; a false value (\f(CW0\fR) is returned otherwise.
.Sp
Example:  To determine whether \f(CW@Don\fR and \f(CW@Ed\fR are equivalent, call:
.Sp
.Vb 4
\&    $eqv = is_LequivalentR(
\&               [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], 
\&               [3,4]
\&           );
\&
\&    $eqv = is_LeqvlntR(                                # alias
\&               [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&               [3,4]
\&           );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $eqv = is_LequivalentR( {
\&        items => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&        pair  => [3,4],
\&    } );
.Ve
.Sp
If no arguments are passed, \f(CW\*(C`is_LequivalentR\*(C'\fR defaults to \f(CW\*(C`[0,1]\*(C'\fR and 
compares the first two lists passed to the function. So,
.Sp
.Vb 1
\&    $eqv = is_LequivalentR( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
\&... translates to:
.Sp
.Vb 1
\&    $eqv = is_LequivalentR( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], [0,1] );
.Ve
.IP "\(bu" 4
To determine whether any two of the lists passed to the function are 
disjoint from one another (\fIi.e.,\fR have no common members), provide 
\&\f(CW\*(C`is_LdisjointR()\*(C'\fR with two array references.
The first is a reference to an array of array 
references, the arrays holding the lists under consideration.  The 
second of these is a reference to a two-element array consisting of the 
two lists being tested for disjointedness.  A true value (\f(CW1\fR) is returned if 
the lists are disjoint; a false value (\f(CW0\fR) is returned otherwise.
.Sp
Example:  To determine whether \f(CW@Don\fR and \f(CW@Ed\fR are disjoint, call:
.Sp
.Vb 4
\&    $disj = is_LdisjointR(
\&               [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], 
\&               [3,4]
\&           );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $disj = is_LdisjointR( {
\&        items => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&        pair  => [3,4]
\&    } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing the subset relationships among the various 
source lists:
.Sp
.Vb 1
\&    print_subset_chart( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_subset_chart( { lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] } );
.Ve
.IP "\(bu" 4
Pretty-print a chart showing the equivalence relationships among the 
various source lists:
.Sp
.Vb 1
\&    print_equivalence_chart( [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] );
.Ve
.Sp
or
.Sp
.Vb 1
\&    print_equivalence_chart( { lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ] } );
.Ve
.IP "\(bu" 4
Determine in \fIwhich\fR (if any) of several lists a given string can be found.  
Pass two array references, the first of which holds references to arrays 
holding the lists under consideration, and the second of which holds a 
single-item list consisting of the string being tested.
.Sp
.Vb 4
\&    @memb_arr = is_member_which( 
\&                    [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                    [ \*(Aqabel\*(Aq ]
\&                );
.Ve
.Sp
or
.Sp
.Vb 4
\&    @memb_arr = is_member_which( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => \*(Aqabel\*(Aq,                                 # value is string
\&    } );
.Ve
.Sp
In list context, return a list of those indices in the function's 
argument list corresponding to lists holding the string being tested.  
In the example above, \f(CW@memb_arr\fR will be:
.Sp
.Vb 1
\&    ( 0 )
.Ve
.Sp
because \f(CW\*(Aqabel\*(Aq\fR is found only in \f(CW@Al\fR which holds position \f(CW0\fR in the 
list of arguments passed to \f(CW\*(C`is_member_which()\*(C'\fR.
.IP "\(bu" 4
As with other List::Compare::Functional functions which return a list, you may 
wish the above function returned a reference to an array holding the list:
.Sp
.Vb 4
\&    $memb_arr_ref = is_member_which_ref(
\&                        [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                        [ \*(Aqjerky\*(Aq ]
\&                    );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_arr_ref = is_member_which_ref( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => \*(Aqjerky\*(Aq,                                # value is string
\&    } );
.Ve
.Sp
In the example above, \f(CW$memb_arr_ref\fR will be:
.Sp
.Vb 1
\&    [ 3, 4 ]
.Ve
.Sp
because \f(CW\*(Aqjerky\*(Aq\fR is found in \f(CW@Don\fR and \f(CW@Ed\fR, which hold positions 
\&\f(CW3\fR and \f(CW4\fR, respectively, in the list of arguments passed to 
\&\f(CW\*(C`is_member_which()\*(C'\fR.
.Sp
\&\fBNote:\fR  functions \f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref\*(C'\fR test
only one string at a time and hence take only one element in the second 
array reference argument.  To test more than one string at a time see 
the next function, \f(CW\*(C`are_members_which()\*(C'\fR.
.IP "\(bu" 4
Determine in \f(CW\*(C`which\*(C'\fR (if any) of several lists one or more given strings 
can be found.  Pass two array references, the first of which holds references 
to arrays holding the lists under consideration, and the second of which 
holds a list of the strings being tested.
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_which(
\&                         [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                         [ qw| abel baker fargo hilton zebra | ]
\&                     );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_which( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],  # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return valus is a reference to a hash of arrays.  In this hash, 
each element's value is a reference to an anonymous array whose 
elements are those indices in the argument list corresponding to 
lists holding the strings being tested.  In the two examples above, 
\&\f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => [ 0             ],
\&         baker    => [ 0, 1          ],
\&         fargo    => [ 0, 1, 2, 3, 4 ],
\&         hilton   => [    1, 2       ],
\&         zebra    => [               ],
\&    };
.Ve
.Sp
\&\fBNote:\fR  \f(CW\*(C`are_members_which()\*(C'\fR tests more than one string at a time.  Hence, 
its second array reference argument can take more than one element.
\&\f(CW\*(C`is_member_which()\*(C'\fR and \f(CW\*(C`is_member_which_ref()\*(C'\fR each take only one element 
in their second array reference arguments.  \f(CW\*(C`are_members_which()\*(C'\fR returns a 
hash reference; the other functions return either a list or a reference to an 
array holding that list, depending on context.
.IP "\(bu" 4
Determine whether a given string can be found in \fIany\fR of several lists.  
Pass two array references, the first of which holds references 
to arrays holding the lists under consideration, and the second of which 
holds a single-item list of the string being tested.
.Sp
.Vb 4
\&    $found = is_member_any(
\&                    [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                    [ \*(Aqabel\*(Aq ]
\&                );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $found = is_member_any( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ], # value is arrayref
\&        item  => \*(Aqabel\*(Aq,                                 # value is string
\&    } );
.Ve
.Sp
The return value is \f(CW1\fR if a specified string can be found in \fIany\fR of 
the lists and \f(CW0\fR if not.  In the example above, \f(CW$found\fR will be 
\&\f(CW1\fR because \f(CW\*(C`abel\*(C'\fR is found in one or more of the lists passed as 
arguments to \f(CW\*(C`is_member_any()\*(C'\fR.
.IP "\(bu" 4
Determine whether a specified string or strings can be found in \fIany\fR of
several lists.  Pass two array references, the first of which holds references 
to arrays holding the lists under consideration, and the second of which 
holds a list of the strings being tested.
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_any(
\&                         [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],
\&                         [ qw| abel baker fargo hilton zebra | ]
\&                     );
.Ve
.Sp
or
.Sp
.Vb 4
\&    $memb_hash_ref = are_members_any( {
\&        lists => [ \e@Al, \e@Bob, \e@Carmen, \e@Don, \e@Ed ],  # value is arrayref
\&        items => [ qw| abel baker fargo hilton zebra | ], # value is arrayref
\&    } );
.Ve
.Sp
The return value is a reference to a hash where an element's key is the 
string being tested and the element's value is \f(CW1\fR if the string can be 
found in any of the lists and \f(CW0\fR if not.  In the example above, 
\&\f(CW$memb_hash_ref\fR will be:
.Sp
.Vb 7
\&    {
\&         abel     => 1,
\&         baker    => 1,
\&         fargo    => 1,
\&         hilton   => 1,
\&         zebra    => 0,
\&    };
.Ve
.Sp
\&\f(CW\*(C`zebra\*(C'\fR's value is \f(CW0\fR because \f(CW\*(C`zebra\*(C'\fR is not found in any of the lists 
passed as arguments to \f(CW\*(C`are_members_any()\*(C'\fR.
.IP "\(bu" 4
Return current List::Compare::Functional version number:
.Sp
.Vb 1
\&    $vers = get_version;
.Ve
.SS "Comparing Lists Held in Seen-Hashes"
.IX Subsection "Comparing Lists Held in Seen-Hashes"
What is a seen-hash?  A seen-hash is a typical Perl implementation of a 
look-up table:  a hash where the value for a given element represents the number 
of times the element's key is observed in a list.  For the purposes of 
List::Compare::Functional, what is crucial is whether an item is observed in a 
list or not; how many times the item occurs in a list is, \fIwith one exception,\fR 
irrelevant.  (That exception is the \f(CW\*(C`get_bag()\*(C'\fR function and its fraternal 
twin \f(CW\*(C`get_bag_ref()\*(C'\fR.  In this case only, the key in each element of the 
seen-hash is placed in the bag the number of times indicated by the value of 
that element.)  The value of an element in a List::Compare seen-hash must be 
a positive integer, but whether that integer is 1 or 1,000,001 is immaterial for 
all List::Compare::Functional functions \fIexcept\fR forming a bag.
.PP
The two lists compared above were represented by arrays; references to 
those arrays were passed to the various List::Compare::Functional functions.
They could, however, have been represented by seen-hashes such as the following 
and passed in exactly the same manner to the various functions.
.PP
.Vb 10
\&    %Llist = (
\&        abel   => 2,
\&        baker  => 1, 
\&        camera => 1,
\&        delta  => 1,
\&        edward => 1,
\&        fargo  => 1,
\&        golfer => 1,
\&    );
\&    %Rlist = (
\&        baker  => 1,
\&        camera => 1,
\&        delta  => 2,
\&        edward => 1,
\&        fargo  => 1,
\&        golfer => 1,
\&        hilton => 1,
\&    );
\&
\&    @intersection = get_intersection( [ \e%Llist, \e%Rlist ] );
\&    @union        = get_union(        [ \e%Llist, \e%Rlist ] );
\&    @complement   = get_complement(   [ \e%Llist, \e%Rlist ] );
.Ve
.PP
and so forth.
.PP
To compare three or more lists simultaneously, provide the appropriate 
List::Compare::Functional function with a first array reference holding a 
list of three or more references to seen-hashes.  Thus,
.PP
.Vb 1
\&    @union = get_intersection( [ \e%Alpha, \e%Beta, \e%Gamma ] );
.Ve
.PP
The 'single hashref' format for List::Compare::Functional functions is 
also available when passing seen-hashes as arguments.  Examples:
.PP
.Vb 3
\&    @intersection = get_intersection( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&    } );
\&
\&    @Ronly = get_complement( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&        item  => 3,
\&    } );
\&
\&    $LR = is_LsubsetR( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&        pair  => [ 4, 2 ],
\&    } );
\&
\&    $memb_hash_ref = are_members_any( {
\&        lists => [ \e%Alpha, \e%Beta, \e%Gamma ],
\&        items => [ qw| abel baker fargo hilton zebra | ], 
\&    } );
.Ve
.SS "Faster Results with the Unsorted Option"
.IX Subsection "Faster Results with the Unsorted Option"
By default, List::Compare::Function functions return lists sorted in Perl's 
default ASCII-betical mode.  Sorting entails a performance cost, and if you 
do not need a sorted list and do not wish to pay this performance cost, you 
may call the following List::Compare::Function functions with the 'unsorted' 
option:
.PP
.Vb 6
\&    @intersection = get_intersection(        \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @union        = get_union(               \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @Lonly        = get_unique(              \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @Ronly        = get_complement(          \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @LorRonly     = get_symmetric_difference(\*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
\&    @bag          = get_bag(                 \*(Aq\-u\*(Aq,  [ \e@Llist, \e@Rlist ] );
.Ve
.PP
For greater readability, the option may be spelled out:
.PP
.Vb 1
\&    @intersection = get_intersection(\*(Aq\-\-unsorted\*(Aq,  [ \e@Llist, \e@Rlist ] );
.Ve
.PP
or
.PP
.Vb 4
\&    @intersection = get_intersection( {
\&        unsorted => 1,
\&        lists    => [ \e@Llist, \e@Rlist ],
\&    } );
.Ve
.PP
Should you need a reference to an unsorted list as the return value, you 
may call the unsorted option as follows:
.PP
.Vb 4
\&    $intersection_ref = get_intersection_ref(
\&                            \*(Aq\-u\*(Aq,         [ \e@Llist, \e@Rlist ] );
\&    $intersection_ref = get_intersection_ref(
\&                            \*(Aq\-\-unsorted\*(Aq, [ \e@Llist, \e@Rlist ] );
.Ve
.SH "DISCUSSION"
.IX Header "DISCUSSION"
.SS "General Comments"
.IX Subsection "General Comments"
List::Compare::Functional is a non-object-oriented implementation of very 
common Perl code used to determine interesting relationships between two 
or more lists at a time.  List::Compare::Functional is based on the same 
author's List::Compare module found in the same \s-1CPAN\s0 distribution.  
List::Compare::Functional is closely modeled on the ''Accelerated'' 
mode in List::Compare.
.PP
For a discussion of the antecedents of this module, see the discussion of the 
history and development of this module in the documentation to List::Compare.
.SS "List::Compare::Functional's Export Tag Groups"
.IX Subsection "List::Compare::Functional's Export Tag Groups"
By default, List::Compare::Functional exports no functions.  You may import 
individual functions into your main package but may find it more convenient to 
import via export tag groups.  Four such groups are currently defined:
.PP
.Vb 4
\&    use List::Compare::Functional qw(:main)
\&    use List::Compare::Functional qw(:mainrefs)
\&    use List::Compare::Functional qw(:originals)
\&    use List::Compare::Functional qw(:aliases)
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:main\*(C'\fR includes what, in the author's opinion, are the six 
List::Compare::Functional subroutines mostly likely to be used:
.Sp
.Vb 6
\&    get_intersection()
\&    get_union()
\&    get_unique()
\&    get_complement()
\&    get_symmetric_difference()
\&    is_LsubsetR()
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:mainrefs\*(C'\fR includes five of the six subroutines found in 
\&\f(CW\*(C`:main\*(C'\fR \*(-- all except \f(CW\*(C`is_LsubsetR()\*(C'\fR \*(-- in the form in which they 
return references to arrays rather than arrays proper:
.Sp
.Vb 5
\&    get_intersection_ref()
\&    get_union_ref()
\&    get_unique_ref()
\&    get_complement_ref()
\&    get_symmetric_difference_ref()
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:originals\*(C'\fR includes all List::Compare::Functional subroutines 
in their 'original' form, \fIi.e.\fR, no aliases for those subroutines:
.Sp
.Vb 10
\&    get_intersection
\&    get_intersection_ref
\&    get_union
\&    get_union_ref
\&    get_unique
\&    get_unique_ref
\&    get_unique_all
\&    get_complement
\&    get_complement_ref
\&    get_complement_all
\&    get_symmetric_difference
\&    get_symmetric_difference_ref
\&    get_shared
\&    get_shared_ref
\&    get_nonintersection
\&    get_nonintersection_ref
\&    is_LsubsetR
\&    is_RsubsetL
\&    is_LequivalentR
\&    is_LdisjointR
\&    is_member_which
\&    is_member_which_ref
\&    are_members_which
\&    is_member_any
\&    are_members_any
\&    print_subset_chart
\&    print_equivalence_chart
\&    get_bag
\&    get_bag_ref
.Ve
.IP "\(bu" 4
Tag group \f(CW\*(C`:aliases\*(C'\fR contains all List::Compare::Functional subroutines 
which are aliases for subroutines found in tag group \f(CW\*(C`:originals\*(C'\fR.  These 
are provided simply for less typing.
.Sp
.Vb 3
\&    get_symdiff
\&    get_symdiff_ref
\&    is_LeqvlntR
.Ve
.SS "April 2004 Change of Interface"
.IX Subsection "April 2004 Change of Interface"
\&\fBNote:\fR  You can skip this section unless you used List::Compare::Functional 
prior to the release of Version 0.25 in April 2004.
.PP
Version 0.25 initiated a significant change in the interface to 
this module's various functions.  In order to be able to accommodate 
comparisons among more than two lists, it was necessary to change the type 
of arguments passed to the various functions.  Whereas previously a 
typical List::Compare::Functional function would be called like this:
.PP
.Vb 1
\&    @intersection = get_intersection( \e@Llist, \e@Rlist ); # SUPERSEDED
.Ve
.PP
\&... now the references to the lists being compared must now be placed 
within a wrapper array (anonymous or named), a reference to which is 
now passed to the function, like so:
.PP
.Vb 1
\&    @intersection = get_intersection( [ \e@Llist, \e@Rlist ] );
.Ve
.PP
\&... or, alternatively:
.PP
.Vb 2
\&    @to_be_compared = (\e@Llist, \e@Rlist);
\&    @intersection = get_intersection( \e@to_be_compared );
.Ve
.PP
In a similar manner, List::Compare::Functional functions could previously 
take arguments in the form of references to 'seen\-hashes' instead of 
references to arrays:
.PP
.Vb 1
\&    @intersection = get_intersection( \e%h0, \e%h1 );
.Ve
.PP
(See above for discussion of seen-hashes.)  Now, those references to 
seen-hashes must be placed within a wrapper array (anonymous or named), 
a reference to which is passed to the function, like so:
.PP
.Vb 1
\&    @intersection = get_intersection( [ \e%h0, \e%h1 ] );
.Ve
.PP
Also, in a similar manner, some List::Compare::Functional functions 
previously took arguments in addition to the lists being compared.  
These arguments were simply passed as scalars, like this:
.PP
.Vb 1
\&    @memb_arr = is_member_which(\e@Llist, \e@Rlist, \*(Aqabel\*(Aq);
.Ve
.PP
Now these arguments must also be placed within a wrapper array 
(anonymous or named), a reference to which is now passed to the function, 
like so:
.PP
.Vb 1
\&    @memb_arr = is_member_which( [ \e@Llist, \e@Rlist ], [ \*(Aqabel\*(Aq ] );
.Ve
.PP
\&... or, alternatively:
.PP
.Vb 3
\&    @to_be_compared = (\e@Llist, \e@Rlist);
\&    @opts = ( \*(Aqabel\*(Aq );
\&    @memb_arr = is_member_which( \e@to_be_compared, \e@opts );
.Ve
.PP
As in previous versions, for a speed boost the user may provide the 
\&\f(CW\*(Aq\-u\*(Aq\fR or \f(CW\*(Aq\-\-unsorted\*(Aq\fR option as the \fIfirst\fR argument to some 
List::Compare::Functional functions.  Using this option, the 
\&\f(CW\*(C`get_intersection()\*(C'\fR function above would appear as:
.PP
.Vb 1
\&    @intersection = get_intersection( \*(Aq\-u\*(Aq, [ \e@Llist, \e@Rlist ] );
.Ve
.PP
\&... or, alternatively:
.PP
.Vb 1
\&    @intersection = get_intersection( \*(Aq\-\-unsorted\*(Aq, [ \e@Llist, \e@Rlist ] );
.Ve
.PP
The arguments to \fIany\fR List::Compare::Functional function will therefore 
consist possibly of the unsorted option, and then of either one or two 
references to arrays, the first of which is a reference to an array of 
arrays or an array of seen-hashes.
.SH "AUTHOR"
.IX Header "AUTHOR"
James E. Keenan (jkeenan@cpan.org).  When sending correspondence, please 
include 'List::Compare::Functional' or 'List\-Compare\-Functional' in your 
subject line.
.PP
Creation date:  May 20, 2002.  Last modification date:  June 07, 2008. 
Copyright (c) 2002\-08 James E. Keenan.  United States.  All rights reserved. 
This is free software and may be distributed under the same terms as Perl
itself.
