.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Util 3"
.TH Module::Util 3 "2013-07-25" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Util \- Module name tools and transformations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Module::Util qw( :all );
\&
\&    $valid = is_valid_module_name $potential_module;
\&
\&    $relative_path = module_path $module_name;
\&
\&    $file_system_path = module_fs_path $module_name;
\&
\&    # load module at runtime
\&    require module_path $module_name;
\&
\&    # (see perldoc \-f require for limitations of this approach.)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a few useful functions for manipulating module names. Its
main aim is to centralise some of the functions commonly used by modules that
manipulate other modules in some way, like converting module names to relative
paths.
.SH "EXPORTS"
.IX Header "EXPORTS"
Nothing by default.
.PP
Use the tag :all to import all functions.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "is_valid_module_name"
.IX Subsection "is_valid_module_name"
.Vb 1
\&    $bool = is_valid_module_name($module)
.Ve
.PP
Returns true if \f(CW$module\fR looks like a module name, false otherwise.
.SS "module_is_loaded"
.IX Subsection "module_is_loaded"
.Vb 1
\&    $abs_path_or_hook = module_is_loaded($module)
.Ve
.PP
Returns the \f(CW%INC\fR entry for the given module. This is usually the absolute path
of the module, but sometimes it is the hook object that loaded it.
.PP
See perldoc \-f require
.PP
Equivalent to:
.PP
.Vb 1
\&    $INC{module_path($module)};
.Ve
.PP
Except that invalid module names simply return false without generating
warnings.
.SS "find_installed"
.IX Subsection "find_installed"
.Vb 1
\&    $path = find_installed($module, [@inc])
.Ve
.PP
Returns the first found installed location of the given module. This is always
an absolute filesystem path, even if it is derived from a relative path in the
include list.
.PP
By default, \f(CW@INC\fR is searched, but this can be overridden by providing extra
arguments.
.PP
.Vb 2
\&    # look in @INC
\&    $path = find_installed("Module::Util")
\&
\&    # look only in lib and blib/lib, not in @INC
\&    $path = find_installed("Module::Util", \*(Aqlib\*(Aq, \*(Aqblib/lib\*(Aq)
.Ve
.PP
Note that this will ignore any references in the search path, so it doesn't
necessarily follow that the module cannot be successfully \f(CW\*(C`require\*(C'\fRd if this
returns nothing.
.SS "all_installed"
.IX Subsection "all_installed"
.Vb 1
\&    @paths = all_installed($module, [@inc])
.Ve
.PP
Like find_installed, but will return multiple results if the module is installed
in multiple locations.
.SS "find_in_namespace"
.IX Subsection "find_in_namespace"
.Vb 1
\&    @modules = find_in_namespace($namespace, [ @inc ])
.Ve
.PP
Searches for modules under a given namespace in the search path (@INC by
default).
.PP
.Vb 1
\&    find_in_namespace("My::Namespace");
.Ve
.PP
Returns unique installed module names under the namespace. Note that this does
not include the passed-in name, even if it is the name of an installed module.
.PP
Use of an empty string as the namespace returns all modules in \f(CW@inc\fR.
.SS "module_path"
.IX Subsection "module_path"
.Vb 1
\&    $path = module_path($module)
.Ve
.PP
Returns a relative path in the form used in \f(CW%INC\fR. Which I am led to believe is
always a unix file path, regardless of the platform.
.PP
If the argument is not a valid module name, nothing is returned.
.SS "module_fs_path"
.IX Subsection "module_fs_path"
.Vb 1
\&    $path = module_fs_path($module)
.Ve
.PP
Like module_path, but returns the path in the native filesystem format.
.PP
On unix systems, this should be identical to module_path.
.SS "path_to_module"
.IX Subsection "path_to_module"
.Vb 1
\&    $module = path_to_module($path)
.Ve
.PP
Transforms a relative unix file path into a module name.
.PP
.Vb 2
\&    # Print loaded modules as module names instead of paths:
\&    print join("\en", map { path_to_module($_) } keys %INC
.Ve
.PP
Returns undef if the resulting module name is not valid.
.SS "fs_path_to_module"
.IX Subsection "fs_path_to_module"
.Vb 1
\&    $module = fs_path_to_module($fs_path)
.Ve
.PP
Transforms relative filesystem paths into module names.
.PP
.Vb 3
\&    # on windows:
\&    fs_path_to_module("Module\e\eUtil.pm")
\&    # returns Module::Util
.Ve
.PP
Returns undef if the resulting module is not valid.
.SS "module_path_parts"
.IX Subsection "module_path_parts"
.Vb 1
\&    @parts = module_path_parts($module_name)
.Ve
.PP
Returns the module name split into parts suitable for feeding to
File::Spec\->catfile.
.PP
.Vb 2
\&    module_path_parts(\*(AqModule::Util\*(Aq)
\&    # returns (\*(AqModule\*(Aq, \*(AqUtil.pm\*(Aq)
.Ve
.PP
If the module name is invalid, nothing is returned.
.SS "canonical_module_name"
.IX Subsection "canonical_module_name"
.Vb 1
\&    $module = canonical_module_name($module);
.Ve
.PP
Returns the canonical module name for the given module. This basically consists
of eliminating any apostrophe symbols and replacing them with '::'.
.PP
.Vb 1
\&    canonical_module_name("Acme::Don\*(Aqt"); # Acme::Don::t
.Ve
.PP
Returns undef if the name is not valid.
.SS "module_name_parts"
.IX Subsection "module_name_parts"
.Vb 1
\&    @parts = module_name_parts($module);
.Ve
.PP
Returns a list of name parts for the given module.
.PP
.Vb 1
\&    module_name_parts(\*(AqAcme::Example); # (\*(AqAcme\*(Aq, \*(AqExample\*(Aq)
.Ve
.SH "BUGS"
.IX Header "BUGS"
None known. Please report any found.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
pm_which, a command-line utility for finding installed perl modules that is
bundled with this module.
.PP
Other, similar \s-1CPAN\s0 modules:
.PP
Class::Inspector, Module::Info,
.PP
Module::Require, UNIVERSAL::require, Module::Runtime
.PP
perldoc \-f require
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Lawrence <mattlaw@cpan.org>
.SH "THANKS"
.IX Header "THANKS"
Alexander Ku\*:hne, Adrian Lai and Daniel Lukasiak for submitting patches.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 Matt Lawrence, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
