.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl6::Slurp 3"
.TH Perl6::Slurp 3 "2013-02-09" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl6::Slurp \- Implements the Perl 6 'slurp' built\-in
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Perl6::Slurp;
\&
\&    # Slurp a file by name...
\&
\&    $file_contents = slurp \*(Aqfilename\*(Aq;
\&    $file_contents = slurp \*(Aq<filename\*(Aq;
\&    $file_contents = slurp \*(Aq<\*(Aq, \*(Aqfilename\*(Aq;
\&    $file_contents = slurp \*(Aq+<\*(Aq, \*(Aqfilename\*(Aq;
\&
\&
\&    # Slurp a file via an (already open!) handle...
\&
\&    $file_contents = slurp \e*STDIN;
\&    $file_contents = slurp $filehandle;
\&    $file_contents = slurp IO::File\->new(\*(Aqfilename\*(Aq);
\&
\&
\&    # Slurp a string...
\&
\&    $str_contents = slurp \e$string;
\&    $str_contents = slurp \*(Aq<\*(Aq, \e$string;
\&
\&
\&    # Slurp a pipe (not on Windows, alas)...
\&
\&    $str_contents = slurp \*(Aqtail \-20 $filename |\*(Aq;
\&    $str_contents = slurp \*(Aq\-|\*(Aq, \*(Aqtail\*(Aq, \-20, $filename;
\&
\&
\&    # Slurp with no source slurps from whatever $_ indicates...
\&
\&    for (@files) {
\&        $contents .= slurp;
\&    }
\&
\&    # ...or from the entire ARGV list, if $_ is undefined...
\&
\&    $_ = undef;
\&    $ARGV_contents = slurp;
\&
\&
\&    # Specify I/O layers as part of mode...
\&
\&    $file_contents = slurp \*(Aq<:raw\*(Aq, $file;
\&    $file_contents = slurp \*(Aq<:utf8\*(Aq, $file;
\&    $file_contents = slurp \*(Aq<:raw :utf8\*(Aq, $file;
\&
\&
\&    # Specify I/O layers as separate options...
\&
\&    $file_contents = slurp $file, {raw=>1};
\&    $file_contents = slurp $file, {utf8=>1};
\&    $file_contents = slurp $file, {raw=>1}, {utf8=>1};
\&    $file_contents = slurp $file, [raw=>1, utf8=>1];
\&
\&
\&    # Specify input record separator...
\&
\&    $file_contents = slurp $file, {irs=>"\en\en"};
\&    $file_contents = slurp \*(Aq<\*(Aq, $file, {irs=>"\en\en"};
\&    $file_contents = slurp {irs=>"\en\en"}, $file;
\&
\&
\&    # Input record separator can be regex...
\&
\&    $file_contents = slurp $file, {irs=>qr/\en+/};
\&    $file_contents = slurp \*(Aq<\*(Aq, $file, {irs=>qr/\en+|\et{2,}};
\&
\&
\&    # Specify autochomping...
\&
\&    $file_contents = slurp $file, {chomp=>1};
\&    $file_contents = slurp {chomp=>1}, $file;
\&    $file_contents = slurp $file, {chomp=>1, irs=>"\en\en"};
\&    $file_contents = slurp $file, {chomp=>1, irs=>qr/\en+/};
\&
\&
\&    # Specify autochomping that replaces irs
\&    # with another string...
\&
\&    $file_contents = slurp $file, {irs=>"\en\en", chomp=>"\en"};
\&    $file_contents = slurp $file, {chomp=>"\en\en"}, {irs=>qr/\en+/};
\&
\&
\&    # Specify autochomping that replaces
\&    # irs with a dynamically computed string...
\&
\&    my $n = 1;
\&    $file_contents = slurp $file, {chomp=>sub{ "\en#line ".$n++."\en"};
\&
\&
\&    # Slurp in a list context...
\&
\&    @lines = slurp \*(Aqfilename\*(Aq;
\&    @lines = slurp $filehandle;
\&    @lines = slurp \e$string;
\&    @lines = slurp \*(Aq<:utf8\*(Aq, \*(Aqfilename\*(Aq, {irs=>"\ex{2020}", chomp=>"\en"};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`slurp\*(C'\fR takes:
.IP "\(bu" 4
a filename,
.IP "\(bu" 4
a filehandle,
.IP "\(bu" 4
a typeglob reference,
.IP "\(bu" 4
an IO::File object, or
.IP "\(bu" 4
a scalar reference,
.PP
converts it to an input stream (using \f(CW\*(C`open()\*(C'\fR if necessary), and reads
in the entire stream. If \f(CW\*(C`slurp\*(C'\fR fails to set up or read the stream, it
throws an exception.
.PP
If no data source is specified \f(CW\*(C`slurp\*(C'\fR uses the value of \f(CW$_\fR as the
source. If \f(CW$_\fR is undefined, \f(CW\*(C`slurp\*(C'\fR uses the \f(CW@ARGV\fR list,
and magically slurps the contents of \fIall\fR the sources listed in \f(CW@ARGV\fR.
Note that the same magic is also applied if you explicitly slurp <*ARGV>, so
the following three input operations:
.PP
.Vb 1
\&    $contents = join "", <ARGV>;
\&
\&    $contents = slurp \e*ARGV;
\&
\&    $/ = undef;
\&    $contents = slurp;
.Ve
.PP
are identical in effect.
.PP
In a scalar context \f(CW\*(C`slurp\*(C'\fR returns the stream contents as a single string.
If the stream is at \s-1EOF,\s0 it returns an empty string.
In a list context, it splits the contents after the appropriate input
record separator and returns the resulting list of strings.
.PP
You can set the input record separator (\f(CW\*(C`{\ irs\ =>\ $your_irs_here}\*(C'\fR) for the input operation. The separator can be specified as a
string or a regex. Note that an explicit input record separator has no
input-terminating effect in a scalar context; \f(CW\*(C`slurp\*(C'\fR always
reads in the entire input stream, whatever the \f(CW\*(Aqirs\*(Aq\fR value.
.PP
In a list context, changing the separator can change how the input is
broken up within the list that is returned.
.PP
If an input record separator is not explicitly specified, \f(CW\*(C`slurp\*(C'\fR
defaults to \f(CW"\en"\fR (\fInot\fR to the current value of \f(CW$/\fR X since
Perl 6 doesn't \fIhave\fR a \f(CW$/\fR);
.PP
You can also tell \f(CW\*(C`slurp\*(C'\fR to automagically \f(CW\*(C`chomp\*(C'\fR the input as it is
read in, by specifying: (\f(CW\*(C`{\ chomp\ =>\ 1\ }\*(C'\fR)
.PP
Better still, you can tell \f(CW\*(C`slurp\*(C'\fR to automagically
\&\f(CW\*(C`chomp\*(C'\fR the input and \fIreplace\fR what it chomps with another string,
by specifying: (\f(CW\*(C`{\ chomp\ =>\ "another\ string"\ }\*(C'\fR)
.PP
You can also tell \f(CW\*(C`slurp\*(C'\fR to compute the replacement string on-the-fly
by specifying a subroutine as the \f(CW\*(C`chomp\*(C'\fR value:
(\f(CW\*(C`{\ chomp\ =>\ sub{...}\ }\*(C'\fR). This subroutine is passed the string
being chomped off, so for example you could squeeze single newlines to a
single space and multiple conseqcutive newlines to a two newlines with:
.PP
.Vb 5
\&    sub squeeze {
\&        my ($removed) = @_;
\&        if ($removed =~ tr/\en/\en/ == 1) { return " " }
\&        else                            { return "\en\en"; }
\&    }
\&
\&    print slurp(\e*DATA, {irs=>qr/[ \et]*\en+/, chomp=>\e&squeeze}), "\en";
.Ve
.PP
Which would transform:
.PP
.Vb 2
\&    This is the
\&    first paragraph
\&
\&
\&    This is the
\&    second
\&    paragraph
\&
\&    This, the
\&    third
\&
\&
\&
\&
\&    This one is
\&    the
\&    very
\&    last
.Ve
.PP
to:
.PP
.Vb 1
\&    This is the first paragraph
\&
\&    This is the second paragraph
\&
\&    This, the third
\&
\&    This one is the very last
.Ve
.PP
Autochomping works in both scalar and list contexts. In scalar contexts every
instance of the input record separator will be removed (or replaced) within
the returned string. In list context, each list item returned with its
terminating separator removed (or replaced).
.PP
You can specify I/O layers, either using the Perl 5 notation:
.PP
.Vb 1
\&    slurp "<:layer1 :layer2 :etc", $filename;
.Ve
.PP
or as an array of options:
.PP
.Vb 2
\&    slurp $filename, [layer1=>1, layer2=>1, etc=>1];
\&    slurp [layer1=>1, layer2=>1, etc=>1], $filename;
.Ve
.PP
or as individual options (each of which must be in a separate hash):
.PP
.Vb 2
\&    slurp $filename, {layer1=>1}, {layer2=>1}, {etc=>1};
\&    slurp {layer1=>1}, {layer2=>1}, {etc=>1}, $filename;
.Ve
.PP
(...which, of course, would look much cooler in Perl 6:
.PP
.Vb 1
\&    # Perl 6 only :\-(
\&
\&    slurp $filename, :layer1 :layer2 :etc;
\&    slurp :layer1 :layer2 :etc, $filename;
.Ve
.PP
)
.PP
A common mistake is to put all the options together in one hash:
.PP
.Vb 1
\&    slurp $filename, {layer1=>1, layer2=>1, etc=>1};
.Ve
.PP
This is almost always a disaster, since the order of I/O layers is usually
critical, and placing them all in one hash effectively randomizes that order.
Use an array instead:
.PP
.Vb 1
\&    slurp $filename, [layer1=>1, layer2=>1, etc=>1];
.Ve
.SH "WARNINGS"
.IX Header "WARNINGS"
The syntax and semantics of Perl 6 is still being finalized
and consequently is at any time subject to change. That means the
same caveat applies to this module.
.PP
When called with a filename or piped shell command, \f(CW\*(C`slurp()\*(C'\fR uses
Perl's built\- in \f(CW\*(C`open()\*(C'\fR to access the file. This means that it
is subject to the same platform-specific limitations as \f(CW\*(C`open()\*(C'\fR.
For example, slurping from piped shell commands may not work 
under Windows.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Requires: Perl 5.8.0, Perl6::Export
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\& Copyright (c) 2003\-2012, Damian Conway. All Rights Reserved.
\& This module is free software. It may be used, redistributed
\&    and/or modified under the same terms as Perl itself.
.Ve
