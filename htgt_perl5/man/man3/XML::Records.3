.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Records 3"
.TH Records 3 "2001-11-05" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Records \- Perlish record\-oriented interface to XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use XML::Records;
\&  my $p=XML::Records\->new(\*(Aqdata.lst\*(Aq);
\&  $p\->set_records(\*(Aqcredit\*(Aq,\*(Aqdebit\*(Aq);
\&  my ($t,$r)
\&  while ( (($t,$r)=$p\->get_record()) && $t) {
\&    my $amt=$r\->{Amount};
\&    if ($t eq \*(Aqdebit\*(Aq) {
\&      ...
\&    }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::Records provides a single interface for processing \s-1XML\s0 data on a 
stream-oriented, tree-oriented, or record-oriented basis.  A subclass of 
XML::TokeParser, it adds methods to read \*(L"records\*(R" and tree fragments from 
\&\s-1XML\s0 documents.
.PP
In many documents, the immediate children of the root element form a 
sequence of identically-named and independent elements such as log entries, 
transactions, etc., each of which consists of \*(L"field\*(R" child elements or 
attributes.  You can access each such \*(L"record\*(R" as a simple Perl hash.
.PP
You can also read any element and its children into a lightweight tree 
implemented as a Perl hash, or feed the contents of any element and its
children into a \s-1SAX\s0 handler (making it possible to process \*(L"records\*(R" with
modules like \s-1XML::DOM\s0 or XML::XPath).
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$parser=XML::Records\->new(source, [options]);" 4
.el .IP "\f(CW$parser\fR=XML::Records\->new(source, [options]);" 4
.IX Item "$parser=XML::Records->new(source, [options]);"
Creates a new parser object
.Sp
\&\fIsource\fR and \fIoptions\fR are the same as for XML::TokeParser. \fIsource\fR is 
either a reference to a string containing the \s-1XML,\s0 the name of a file 
containing the \s-1XML,\s0 or an open IO::Handle or filehandle glob reference from 
which the \s-1XML\s0 can be read.
.ie n .IP "$parser\->set_records(name [,name]*);" 4
.el .IP "\f(CW$parser\fR\->set_records(name [,name]*);" 4
.IX Item "$parser->set_records(name [,name]*);"
Specifies what \s-1XML\s0 element-type names enclose records.  If a name is
prefixed with '\-' then the reader will treat a start-tag for that name as
indicating the end of a record.
.IP "($type,$record)=$parser\->get_record([{options}] [name [,name]*]);" 4
.IX Item "($type,$record)=$parser->get_record([{options}] [name [,name]*]);"
Retrieves the next record from the input, skipping through the \s-1XML\s0 input 
until it encounters a start tag for one of the elements that enclose 
records.  If the first argument is a hash reference and the value of the 
key 'here' is set to a non-zero value, then non-comment tokens will not be 
skipped and the method will return (undef,undef) if the next token is not a 
start tag for a record-enclosing element (the token will be pushed back in 
this case).  If arguments are given, they will temporarily replace the set 
of record-enclosing elements.  The method will return a list consisting of 
the name of the record's enclosing element and a reference to a hash whose 
keys are the names of the record's child elements (\*(L"fields\*(R") and whose 
values are the fields' contents (if called in scalar context, the return 
value will be the hash reference).  Both elements of the list will be undef 
if no record can be found.
.Sp
If a field's content is plain text, its value will be that text.  If a field element
has attributes, its value will be a reference to an array whose first element is the
field's (possibly empty) text value and whose second element is a reference to a hash
of the attributes and their values.
.Sp
If a field's content contains another element (e.g. a <customer> record 
contains an <address> field that in turn contains other fields), its value 
will be a reference to another hash containing the \*(L"sub\-record\*(R"'s fields.
.Sp
If a record includes repeated fields, the hash entry for that field's 
name will be a reference to an array of field values.
.Sp
Attributes of record or sub-record elements are treated as if they were 
fields.  Mixed content (fields with both non-whitespace text and sub-elements)
will lead to unpredictable results.
.Sp
Records do not actually need to be immediately below the document 
root.  If a <customers> document consists of a sequence of <customer> 
elements which in turn contain <address> elements that include further 
elements, then calling get_record with the record type set to \*(L"address\*(R" 
will return the contents of each <address> element.
.ie n .IP "$tree=$parser\->get_simple_tree([{options}] [name [,name]*]);" 4
.el .IP "\f(CW$tree\fR=$parser\->get_simple_tree([{options}] [name [,name]*]);" 4
.IX Item "$tree=$parser->get_simple_tree([{options}] [name [,name]*]);"
Returns a lightweight tree rooted at the next element whose name is listed 
in the arguments, or at the next start-tag token if no arguments are given, 
skipping over any intermediate tokens unless the 'here' option is set as in 
\&\fIget_record()\fR.
.Sp
The return value is a hash reference to the root node of the tree.  Each 
node is a hash with a 'type' key whose value is the node's type: 'e' for 
elements, 't' for text, and 'p' for processing instructions; and a 
\&'content' key whose value is a reference to an array of the element's 
child nodes for element nodes, the string value for text nodes, and the 
data value for processing instruction nodes.  Element nodes also have an 
\&'attrib' key whose value is a reference to a hash of attribute names and 
values.  Processing instructions also have a 'target' key whose value is 
the \s-1PI\s0's target.
.Sp
This method is deprecated; future code should instantiate an XML::Handler::EasyTree
object from the XML::Handler::Trees module and call drive_SAX (see below) on it.
.ie n .IP "$result=$parser\->drive_SAX(handler, [{options},[name [,name]*]);" 4
.el .IP "\f(CW$result\fR=$parser\->drive_SAX(handler, [{options},[name [,name]*]);" 4
.IX Item "$result=$parser->drive_SAX(handler, [{options},[name [,name]*]);"
Skips to the next element whose names is listed in the arguments, or the 
next element if no arguments are given, and generates PerlSAX events which 
are sent to the \s-1SAX\s0 handler object in handler as if the element were an 
entire document. The return value is whatever the handler returned in 
response to the end_document event.  If the 'here' option is set, returns 
undef without generating any \s-1SAX\s0 events if the next non-comment token is 
not a start tag for a record-enclosing element.  If the 'wrap' option is 
set to 0, does not generate start_document or end_document events and 
returns 1.
.Sp
At the present time, only \s-1SAX1\s0 is supported.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Print a list of package names from a (rather out-of-date) list of \s-1XML\s0 modules:"
.IX Subsection "Print a list of package names from a (rather out-of-date) list of XML modules:"
.Vb 3
\& #!perl \-w
\& use strict;
\& use XML::Records;
\& 
\& my $p=XML::Records\->new(\*(Aqmodules.xml\*(Aq) or die "$!";
\& $p\->set_records(\*(Aqmodule\*(Aq);
\& while (my $record=$p\->get_record()) {
\&   my $pkg=$record\->{package};
\&   if (ref $pkg eq \*(AqARRAY\*(Aq) {
\&     for my $subpkg (@$pkg) {
\&       print $subpkg\->{name},"\en";
\&     }
\&   }
\&   else {
\&     print $pkg\->{name},"\en";
\&   }
\& }
.Ve
.SS "Extract interesting items from an \s-1RSS 0.91\s0 file"
.IX Subsection "Extract interesting items from an RSS 0.91 file"
.Vb 4
\& #!perl \-w
\& use strict;
\& use XML::Records;
\& use XML::Handler::YAWriter;
\&
\& my $r=XML::Records\->new(\*(Aqmessages.rss\*(Aq);
\& $r\->set_records(\*(Aqitem\*(Aq);
\& my $h=XML::Handler::YAWriter\->new(AsString=>1);
\& $h\->start_document({});
\& $h\->start_element({Name=>\*(Aqitems\*(Aq});
\& while (my $t=$r\->get_tag(\*(Aqitem\*(Aq)) {
\&   $r\->unget_token($t);
\&   $r\->begin_saving();
\&   my $text=$r\->get_text(\*(Aq/item\*(Aq);
\&   if ($text=~/perl/i) {
\&     $r\->restore_saved();
\&     $r\->drive_SAX($h,{wrap=>0,here=>1});
\&   }
\& }
\& $h\->end_element({Name=>\*(Aqitems\*(Aq});
\& print $h\->end_document({});
.Ve
.SH "RATIONALE"
.IX Header "RATIONALE"
\&\s-1XML::RAX,\s0 which implements the proposed \s-1RAX\s0 standard for record-oriented 
\&\s-1XML\s0 access, does much of what XML::Records does but its interface is not 
very Perlish (due to the fact that \s-1RAX\s0 is a language-independent 
interface), it cannot cope with fields that have sub-structure (because \s-1RAX \s0
itself doesn't address the issue), and it doesn't allow mixing record\- 
oriented and non-record-oriented operations.
.PP
XML::Twig allows access to tree fragments, but only on a \*(L"push\*(R" (callback\- 
driven) basis, and does not allow mixed tree\- and token-level access.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
XML::TokeParser (version 0.03 or higher), XML::Parser.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eric Bohlman (ebohlman@earthlink.net, ebohlman@omsdev.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 Eric Bohlman.  All rights reserved.
.PP
This program is free software; you can use/modify/redistribute it under the
same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 5
\&  XML::TokeParser
\&  XML::RAX
\&  XML::Twig
\&  XML::Parser::PerlSAX
\&  perl(1).
.Ve
