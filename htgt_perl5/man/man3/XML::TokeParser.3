.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TokeParser 3"
.TH TokeParser 3 "2003-06-09" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::TokeParser \- Simplified interface to XML::Parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    use XML::TokeParser;
\&                                                                    #
\&    #parse from file
\&    my $p = XML::TokeParser\->new(\*(Aqfile.xml\*(Aq)
\&                                                                    #
\&    #parse from open handle
\&    open IN, \*(Aqfile.xml\*(Aq or die $!;
\&    my $p = XML::TokeParser\->new( \e*IN, Noempty => 1 );
\&                                                                    #
\&    #parse literal text
\&    my $text = \*(Aq<tag xmlns="http://www.omsdev.com">text</tag>\*(Aq;
\&    my $p    = XML::TokeParser\->new( \e$text, Namespaces => 1 );
\&                                                                    #
\&    #read next token
\&    my $token = $p\->get_token();
\&                                                                    #
\&    #skip to <title> and read text
\&    $p\->get_tag(\*(Aqtitle\*(Aq);
\&    $p\->get_text();
\&                                                                    #
\&    #read text of next <para>, ignoring any internal markup
\&    $p\->get_tag(\*(Aqpara\*(Aq);
\&    $p\->get_trimmed_text(\*(Aq/para\*(Aq);
\&                                                                    #
\&    #process <para> if interesting text
\&    $t = $p\->get_tag(\*(Aqpara\*(Aq);
\&    $p\->begin_saving($t);
\&    if ( $p\->get_trimmed_text(\*(Aq/para\*(Aq) =~ /interesting stuff/ ) {
\&        $p\->restore_saved();
\&        process_para($p);
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::TokeParser provides a procedural (\*(L"pull mode\*(R") interface to XML::Parser
in much the same way that Gisle Aas' HTML::TokeParser provides a procedural
interface to HTML::Parser.  XML::TokeParser splits its \s-1XML\s0 input up into
\&\*(L"tokens,\*(R" each corresponding to an XML::Parser event.
.PP
A token is a \fBbless'd\fR reference to an array whose first element is an event-type 
string and whose last element is the literal text of the \s-1XML\s0 input that 
generated the event, with intermediate elements varying according to the 
event type.
.PP
Each token is an \fIobject\fR of type XML::TokeParser::Token.
Read 
\&\*(L"XML::TokeParser::Token\*(R"
to learn what methods are available for inspecting the token,
and retrieving data from it.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$p = XML::TokeParser\->new($input, [options])" 4
.el .IP "\f(CW$p\fR = XML::TokeParser\->new($input, [options])" 4
.IX Item "$p = XML::TokeParser->new($input, [options])"
Creates a new parser, specifying the input source and any options.  If 
\&\f(CW$input\fR is a string, it is the name of the file to parse.  If \f(CW$input\fR is a 
reference to a string, that string is the actual text to parse.  If \f(CW$input\fR 
is a reference to a typeglob or an IO::Handle object corresponding to an 
open file or socket, the text read from the handle will be parsed.
.Sp
Options are name=>value pairs and can be any of the following:
.RS 4
.IP "Namespaces" 4
.IX Item "Namespaces"
If set to a true value, namespace processing is enabled.
.IP "ParseParamEnt" 4
.IX Item "ParseParamEnt"
This option is passed on to the underlying XML::Parser object; see that 
module's documentation for details.
.IP "Noempty" 4
.IX Item "Noempty"
If set to a true value, text tokens consisting of only whitespace (such as 
those created by indentation and line breaks in between tags) will be 
ignored.
.IP "Latin" 4
.IX Item "Latin"
If set to a true value, all text other than the literal text elements of 
tokens will be translated into the \s-1ISO 8859\-1 \s0(Latin\-1) character encoding 
rather than the normal \s-1UTF\-8\s0 encoding.
.IP "Catalog" 4
.IX Item "Catalog"
The value is the \s-1URI\s0 of a catalog file used to resolve \s-1PUBLIC\s0 and \s-1SYSTEM \s0
identifiers.  See XML::Catalog for details.
.RE
.RS 4
.RE
.ie n .IP "$token = $p\->\fIget_token()\fR" 4
.el .IP "\f(CW$token\fR = \f(CW$p\fR\->\fIget_token()\fR" 4
.IX Item "$token = $p->get_token()"
Returns the next token, as an array reference, from the input.  Returns 
undef if there are no remaining tokens.
.ie n .IP "$p\->unget_token($token,...)" 4
.el .IP "\f(CW$p\fR\->unget_token($token,...)" 4
.IX Item "$p->unget_token($token,...)"
Pushes tokens back so they will be re-read.  Useful if you've read one or 
more tokens too far.  Correctly handles \*(L"partial\*(R" tokens returned by 
\&\fIget_tag()\fR.
.ie n .IP "$token = $p\->get_tag( [$token] )" 4
.el .IP "\f(CW$token\fR = \f(CW$p\fR\->get_tag( [$token] )" 4
.IX Item "$token = $p->get_tag( [$token] )"
If no argument given, skips tokens until the next start tag or end tag 
token. If an argument is given, skips tokens until the start tag or end tag 
(if the argument begins with '/') for the named element.  The returned 
token does not include an event type code; its first element is the element 
name, prefixed by a '/' if the token is for an end tag.
.ie n .IP "$text = $p\->get_text( [$token] )" 4
.el .IP "\f(CW$text\fR = \f(CW$p\fR\->get_text( [$token] )" 4
.IX Item "$text = $p->get_text( [$token] )"
If no argument given, returns the text at the current position, or an empty 
string if the next token is not a 'T' token.  If an argument is given, 
gathers up all text between the current position and the specified start or 
end tag, stripping out any intervening tags (much like the way a typical 
Web browser deals with unknown tags).
.ie n .IP "$text = $p\->get_trimmed_text( [$token] )" 4
.el .IP "\f(CW$text\fR = \f(CW$p\fR\->get_trimmed_text( [$token] )" 4
.IX Item "$text = $p->get_trimmed_text( [$token] )"
Like \fIget_text()\fR, but deletes any leading or trailing whitespaces and 
collapses multiple whitespace (including newlines) into single spaces.
.ie n .IP "$p\->begin_saving( [$token] )" 4
.el .IP "\f(CW$p\fR\->begin_saving( [$token] )" 4
.IX Item "$p->begin_saving( [$token] )"
Causes subsequent calls to \fIget_token()\fR, \fIget_tag()\fR, \fIget_text()\fR, and 
\&\fIget_trimmed_text()\fR to save the returned tokens.  In conjunction with 
\&\fIrestore_saved()\fR, allows you to \*(L"back up\*(R" within a token stream.  If an 
argument is supplied, it is placed at the beginning of the list of saved 
tokens (useful because you often won't know you want to begin saving until 
you've already read the first token you want saved).
.ie n .IP "$p\->\fIrestore_saved()\fR" 4
.el .IP "\f(CW$p\fR\->\fIrestore_saved()\fR" 4
.IX Item "$p->restore_saved()"
Pushes all the tokens saved by \fIbegin_saving()\fR back onto the token stream.  
Stops saving tokens.  To cancel saving without backing up, call 
\&\fIbegin_saving()\fR and \fIrestore_saved()\fR in succession.
.SS "XML::TokeParser::Token"
.IX Subsection "XML::TokeParser::Token"
A token is a blessed array reference,
that you acquire using \f(CW\*(C`$p\->get_token\*(C'\fR or \f(CW\*(C`$p\->get_tag\*(C'\fR,
and that might look like:
.PP
.Vb 5
\&    ["S",  $tag, $attr, $attrseq, $raw]
\&    ["E",  $tag, $raw]
\&    ["T",  $text, $raw]
\&    ["C",  $text, $raw]
\&    ["PI", $target, $data, $raw]
.Ve
.PP
If you don't like remembering array indices (you're a real programmer),
you may access the attributes of a token like:
.PP
\&\f(CW\*(C`$t\->tag\*(C'\fR, \f(CW\*(C`$t\->attr\*(C'\fR, \f(CW\*(C`$t\->attrseq\*(C'\fR, \f(CW\*(C`$t\->raw\*(C'\fR,
\&\f(CW\*(C`$t\->text\*(C'\fR, \f(CW\*(C`$t\->target\*(C'\fR, \f(CW\*(C`$t\->data\*(C'\fR.
.PP
\&\fB****Please note that this may change in the future,\fR
\&\fBwhere as there will be 4 token types, XML::TokeParser::Token::StartTag ....\fR
.PP
What kind of token is it?
.PP
To find out, inspect your token using any of these is_* methods
(1 == true, 0 == false, d'oh):
.IP "is_text" 4
.IX Item "is_text"
.PD 0
.IP "is_comment" 4
.IX Item "is_comment"
.IP "is_pi which is short for is_process_instruction" 4
.IX Item "is_pi which is short for is_process_instruction"
.IP "is_start_tag" 4
.IX Item "is_start_tag"
.IP "is_end_tag" 4
.IX Item "is_end_tag"
.IP "is_tag" 4
.IX Item "is_tag"
.PD
.PP
What's that token made of?
To retrieve data from your token, use any of the following methods,
depending on the kind of token you have:
.IP "target" 4
.IX Item "target"
only for process instructions
.IP "data" 4
.IX Item "data"
only for process instructions
.IP "raw" 4
.IX Item "raw"
for all tokens
.IP "attr" 4
.IX Item "attr"
only for start tags, returns a hashref ( \f(CW\*(C`print "#link ", \*(C'\fR\f(CW\*(C`$t\->attr\*(C'\fR\f(CW\*(C`\->{href}\*(C'\fR ).
.ie n .IP "my $attrseq = $t\->attrseq" 4
.el .IP "my \f(CW$attrseq\fR = \f(CW$t\fR\->attrseq" 4
.IX Item "my $attrseq = $t->attrseq"
only for start tags, returns an array ref of the keys found in \f(CW\*(C`$t\->attr\*(C'\fR
in the order they originally appeared in.
.ie n .IP "my $tagname = $t\->tag" 4
.el .IP "my \f(CW$tagname\fR = \f(CW$t\fR\->tag" 4
.IX Item "my $tagname = $t->tag"
only for tags ( \f(CW\*(C`print "opening ", \*(C'\fR\f(CW\*(C`$t\->tag\*(C'\fR\f(CW\*(C` if \*(C'\fR\f(CW\*(C`$t\->is_start_tag\*(C'\fR ).
.ie n .IP "my $text = $token\->text" 4
.el .IP "my \f(CW$text\fR = \f(CW$token\fR\->text" 4
.IX Item "my $text = $token->text"
only for tokens of type text and comment
.PP
Here's more detailed info about the tokens.
.IP "Start tag" 4
.IX Item "Start tag"
The token has five elements: 'S', the element's name, a reference to a hash 
of attribute values keyed by attribute names, a reference to an array of 
attribute names in the order in which they appeared in the tag, and the 
literal text.
.IP "End tag" 4
.IX Item "End tag"
The token has three elements: 'E', the element's name, and the literal text.
.IP "Character data (text)" 4
.IX Item "Character data (text)"
The token has three elements: 'T', the parsed text, and the literal text.  
All contiguous runs of text are gathered into single tokens; there will 
never be two 'T' tokens in a row.
.IP "Comment" 4
.IX Item "Comment"
The token has three elements: 'C', the parsed text of the comment, and the 
literal text.
.IP "Processing instruction" 4
.IX Item "Processing instruction"
The token has four elements: '\s-1PI\s0', the target, the data, and the literal 
text.
.PP
The literal text includes any markup delimiters (pointy brackets, 
<![CDATA[, etc.), entity references, and numeric character references and 
is in the \s-1XML\s0 document's original character encoding.  All other text is in 
\&\s-1UTF\-8 \s0(unless the Latin option is set, in which case it's in \s-1ISO\-8859\-1\s0) 
regardless of the original encoding, and all entity and character 
references are expanded.
.PP
If the Namespaces option is set, element and attribute names are prefixed 
by their (possibly empty) namespace URIs enclosed in curly brackets and 
xmlns:* attributes do not appear in 'S' tokens.
.SH "DIFFERENCES FROM HTML::TokeParser"
.IX Header "DIFFERENCES FROM HTML::TokeParser"
Uses a true \s-1XML\s0 parser rather than a modified \s-1HTML\s0 parser.
.PP
Text and comment tokens include extracted text as well as literal text.
.PP
\&\s-1PI\s0 tokens include target and data as well as literal text.
.PP
No tokens for declarations.
.PP
No \*(L"textify\*(R" hash.
.PP
unget_token correctly handles partial tokens returned by \fIget_tag()\fR.
.PP
\&\fIbegin_saving()\fR and \fIrestore_saved()\fR
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Example:
.PP
.Vb 10
\&    use XML::TokeParser;
\&    use strict;
\&                                                                               #
\&    my $text = \*(Aq<tag foo="bar" foy="floy"> some text <!\-\-comment\-\-></tag>\*(Aq;
\&    my $p    = XML::TokeParser\->new( \e$text );
\&                                                                               #
\&    print $/;
\&                                                                               #
\&    while( defined( my $t = $p\->get_token() ) ){
\&        local $\e="\en";
\&        print \*(Aq         raw = \*(Aq, $t\->raw;
\&                                                                               #
\&        if( $t\->tag ){
\&            print \*(Aq         tag = \*(Aq, $t\->tag;
\&                                                                               #
\&            if( $t\->is_start_tag ) {
\&                print \*(Aq        attr = \*(Aq, join \*(Aq,\*(Aq, %{$t\->attr};
\&                print \*(Aq     attrseq = \*(Aq, join \*(Aq,\*(Aq, @{$t\->attrseq};
\&            }
\&                                                                               #
\&            print \*(Aqis_tag       \*(Aq, $t\->is_tag;
\&            print \*(Aqis_start_tag \*(Aq, $t\->is_start_tag;
\&            print \*(Aqis_end_tag   \*(Aq, $t\->is_end_tag;
\&        }
\&        elsif( $t\->is_pi ){
\&            print \*(Aq      target = \*(Aq, $t\->target;
\&            print \*(Aq        data = \*(Aq, $t\->data;
\&            print \*(Aqis_pi        \*(Aq, $t\->is_pi;
\&        }
\&        else {
\&            print \*(Aq        text = \*(Aq, $t\->text;
\&            print \*(Aqis_text      \*(Aq, $t\->is_text;
\&            print \*(Aqis_comment   \*(Aq, $t\->is_comment;
\&        }
\&                                                                               #
\&        print $/;
\&    }
\&    _\|_END_\|_
.Ve
.PP
Output:
.PP
.Vb 7
\&             raw = <tag foo="bar" foy="floy">
\&             tag = tag
\&            attr = foo,bar,foy,floy
\&         attrseq = foo,foy
\&    is_tag       1
\&    is_start_tag 1
\&    is_end_tag   0
\&
\&
\&             raw =  some text 
\&            text =  some text 
\&    is_text      1
\&    is_comment   0
\&
\&
\&             raw = <!\-\-comment\-\->
\&            text = comment
\&    is_text      0
\&    is_comment   1
\&
\&
\&             raw = </tag>
\&             tag = tag
\&    is_tag       1
\&    is_start_tag 0
\&    is_end_tag   1
.Ve
.SH "BUGS"
.IX Header "BUGS"
To report bugs, go to
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML\-TokeParser>
or send mail to <bug\-XML\-Tokeparser@rt.cpan.org>
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2003 D.H. aka PodMaster (current maintainer).
Copyright (c) 2001 Eric Bohlman (original author).
.PP
All rights reserved.
This program is free software;
you can redistribute it and/or modify it
under the same terms as Perl itself.
If you don't know what this means,
visit <http://perl.com/> or <http://cpan.org/>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::TokeParser,
XML::Parser,
XML::Catalog,
XML::Smart,
XML::Twig.
