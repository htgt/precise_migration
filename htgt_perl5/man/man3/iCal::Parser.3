.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "iCal::Parser 3"
.TH iCal::Parser 3 "2013-06-15" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
iCal::Parser \- Parse iCalendar files into a data structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use iCal::Parser
\&
\&  my $parser=iCal::Parser\->new();
\&  my $hash=$parser\->parse($file);
\&
\&  $parser\->parse($another_file);
\&  my $combined=$parser\->calendar;
\&
\&  my $combined=iCal::Parser\->new\->parse(@files);
\&  my $combined=iCal::Parser\->new\->parse_files(@files);
\&  my $combined=iCal::Parser\->new\->parse_strings(@strings);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module processes iCalendar (vCalendar 2.0) files as specified in \s-1RFC 2445\s0
into a data structure.
It handles recurrences (\f(CW\*(C`RRULE\*(C'\fRs), exclusions (\f(CW\*(C`EXDATE\*(C'\fRs), event updates
(events with a \f(CW\*(C`RECURRENCE\-ID\*(C'\fR), and nested data structures (\f(CW\*(C`ATTENDEES\*(C'\fR and
\&\f(CW\*(C`VALARM\*(C'\fRs). It currently ignores the \f(CW\*(C`VTIMEZONE\*(C'\fR, \f(CW\*(C`VJOURNAL\*(C'\fR and
\&\f(CW\*(C`VFREEBUSY\*(C'\fR entry types.
.PP
The data structure returned is a hash like the following:
.PP
.Vb 5
\&    {
\&      calendars=>[\e%cal, ...],
\&      events=>{yyyy=>{mm=>{dd}=>{UID=>\e%event}}
\&      todos=>[\e%todo, ...]
\&    }
.Ve
.PP
That is, it contains an array of calendar hashes, a hash of events key by
\&\f(CW\*(C`year=>month=>day=>eventUID\*(C'\fR, and an array of todos.
.PP
Calendars, events and todos are \*(L"rolled up\*(R" version os the hashes returned from
Text::vFile::asData, with dates replaced by \f(CW\*(C`DateTime\*(C'\fR objects.
.PP
During parsing, events in the input calendar are expanded out into multiple
events, one per day covered by the event, as follows:
.IP "\(bu" 4
If the event is a one day \*(L"all day\*(R" event (in ical, the event is 24hrs long,
starts at midnight on the day and ends a midnight of the next day),
it contains no \f(CW\*(C`hour\*(C'\fR field and the \f(CW\*(C`allday\*(C'\fR field is set to \f(CW1\fR.
.IP "\(bu" 4
If the event is a recurrence (\f(CW\*(C`RRULE\*(C'\fR), one event per day is created as
per the \f(CW\*(C`RRULE\*(C'\fR specification.
.IP "\(bu" 4
If the event spans more than one day (the start and end dates are on different
days, but does not contain an \f(CW\*(C`RRULE\*(C'\fR),
it is expanded into multiple events, the first events end time is set
to midnight, subsequent events are set to start at midnight and end at
midnight the following day (same as an \*(L"allday\*(R" event, but the \f(CW\*(C`allday\*(C'\fR field
is not set), and the last days event is set to run from midnight to the
end time of the original multi-day event.
.IP "\(bu" 4
If the event is an update (it contains a \f(CW\*(C`RECURRENCE\-ID\*(C'\fR), the original
event is updated. If the referenced event does not exist (e.g., it was
deleted after the update), then the event is added as a new event.
.PP
An example of each hash is below.
.SS "Calendar Hash"
.IX Subsection "Calendar Hash"
.Vb 10
\&    {
\&        \*(AqX\-WR\-CALNAME\*(Aq => \*(AqTest\*(Aq,
\&        \*(Aqindex\*(Aq => 1,
\&        \*(AqX\-WR\-RELCALID\*(Aq => \*(Aq7CCE8555\-3516\-11D9\-8A43\-000D93C45D90\*(Aq,
\&        \*(AqPRODID\*(Aq => \*(Aq\-//Apple Computer\e\e, Inc//iCal 1.5//EN\*(Aq,
\&        \*(AqCALSCALE\*(Aq => \*(AqGREGORIAN\*(Aq,
\&        \*(AqX\-WR\-TIMEZONE\*(Aq => \*(AqAmerica/New_York\*(Aq,
\&        \*(AqX\-WR\-CALDESC\*(Aq => \*(AqMy Test Calendar\*(Aq,
\&        \*(AqVERSION\*(Aq => \*(Aq2.0\*(Aq
\&    }
.Ve
.SS "Event Hash"
.IX Subsection "Event Hash"
Note that \f(CW\*(C`hours\*(C'\fR and \f(CW\*(C`allday\*(C'\fR are mutually exclusive in the actual data.
The \f(CW\*(C`idref\*(C'\fR field contains the \f(CW\*(C`id\*(C'\fR of the calendar the event
came from, which is useful if the hash was created from multiple calendars.
.PP
.Vb 10
\&    {
\&        \*(AqSUMMARY\*(Aq => \*(Aqovernight\*(Aq,
\&        \*(Aqhours\*(Aq => \*(Aq15.00\*(Aq,
\&        \*(Aqallday\*(Aq => 1,
\&        \*(AqUID\*(Aq => \*(Aq95CCBF98\-3685\-11D9\-8CA5\-000D93C45D90\*(Aq,
\&        \*(Aqidref\*(Aq => \*(Aq7CCE8555\-3516\-11D9\-8A43\-000D93C45D90\*(Aq,
\&        \*(AqDTSTAMP\*(Aq => \e%DateTime,
\&        \*(AqDTEND\*(Aq => \e%DateTime,
\&        \*(AqDTSTART\*(Aq => \e%DateTime
\&        \*(AqATTENDEE\*(Aq => [
\&           {
\&              \*(AqCN\*(Aq => \*(AqJay\*(Aq,
\&              \*(Aqvalue\*(Aq => \*(Aqmailto:jayl@my.server\*(Aq
\&           },
\&          ],
\&          \*(AqVALARM\*(Aq => [
\&            {
\&              \*(Aqwhen\*(Aq => \e%DateTime,
\&              \*(AqSUMMARY\*(Aq => \*(AqAlarm notification\*(Aq,
\&              \*(AqACTION\*(Aq => \*(AqEMAIL\*(Aq,
\&              \*(AqDESCRIPTION\*(Aq => \*(AqThis is an event reminder\*(Aq,
\&              \*(AqATTENDEE\*(Aq => [
\&                 {
\&                   \*(Aqvalue\*(Aq => \*(Aqmailto:cpan@my.server\*(Aq
\&                 }
\&              ]
\&           }
\&         ],
\&    }
.Ve
.SS "Todo Hash"
.IX Subsection "Todo Hash"
.Vb 10
\&    {
\&        \*(AqURL\*(Aq => \*(Aqmailto:me\*(Aq,
\&        \*(AqSUMMARY\*(Aq => \*(Aqtodo 1\*(Aq,
\&        \*(AqUID\*(Aq => \*(AqB78E68F2\-35E7\-11D9\-9E64\-000D93C45D90\*(Aq,
\&        \*(Aqidref\*(Aq => \*(Aq7CCE8555\-3516\-11D9\-8A43\-000D93C45D90\*(Aq,
\&        \*(AqSTATUS\*(Aq => \*(AqCOMPLETED\*(Aq,
\&        \*(AqCOMPLETED\*(Aq => \e%DateTime,
\&        \*(AqDTSTAMP\*(Aq => \e%DateTime,
\&        \*(AqPRIORITY\*(Aq => \*(Aq9\*(Aq,
\&        \*(AqDTSTART\*(Aq => \e%DateTime,
\&        \*(AqDUE\*(Aq => \e%DateTime,
\&        \*(AqDESCRIPTION\*(Aq => \*(Aqnot much\*(Aq,
\&        \*(AqVALARM\*(Aq => [
\&           {
\&              \*(Aqwhen\*(Aq => \e%DateTime,
\&              \*(AqATTACH\*(Aq => \*(Aqfile://localhost/my\-file\*(Aq,
\&              \*(AqACTION\*(Aq => \*(AqPROCEDURE\*(Aq
\&           }
\&        ],
\&    },
.Ve
.SH "Methods"
.IX Header "Methods"
.SS "new(%opt_args)"
.IX Subsection "new(%opt_args)"
\fIOptional Arguments\fR
.IX Subsection "Optional Arguments"
.IP "start {yyymmdd|DateTime}" 4
.IX Item "start {yyymmdd|DateTime}"
Only include events on or after \f(CW\*(C`yyymmdd\*(C'\fR. Defaults to Jan of this year.
.IP "end {yyyymmdd|DateTime}" 4
.IX Item "end {yyyymmdd|DateTime}"
Only include events before \f(CW\*(C`yyymmdd\*(C'\fR.
.IP "no_events" 4
.IX Item "no_events"
Don't include events in the output (todos only).
.IP "no_todos" 4
.IX Item "no_todos"
Don't include todos in the output (events only).
.IP "months n" 4
.IX Item "months n"
DateTime::Sets (used for calculating recurrences) are limited to
approximately 200 entries. If an \f(CW\*(C`end\*(C'\fR date is not specified, the
\&\f(CW\*(C`to\*(C'\fR date is set to the \f(CW\*(C`start\*(C'\fR date plus this many months.
The default is 60.
.IP "tz (string|DateTime::TimeZone)" 4
.IX Item "tz (string|DateTime::TimeZone)"
Use tz as timezone for date values.
The default is 'local', which will adjust the parsed dates to the current timezone.
.IP "debug" 4
.IX Item "debug"
Set to non-zero for some debugging output during processing.
.SS "parse({file|file_handle}+)"
.IX Subsection "parse({file|file_handle}+)"
Parse the input files or opened file handles and return the generated hash.
.PP
This function can be called mutitple times and the calendars will be
merge into the hash, each event tagged with the unique id of its calendar.
.SS "parse_files({file|file_handle}+)"
.IX Subsection "parse_files({file|file_handle}+)"
Alias for \f(CW\*(C`parse()\*(C'\fR
.SS "parse_strings(string+)"
.IX Subsection "parse_strings(string+)"
Parse the input strings (each assumed to be a valid iCalendar) and return
the generated hash.
.SH "AUTHOR"
.IX Header "AUTHOR"
Rick Frankel, cpan@rickster.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::vFile::asData, DateTime::Set, DateTime::Span,
iCal::Parser::SAX
